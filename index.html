<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cycle Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { background: #080a10; min-height: 100vh; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
import { useState, useMemo, useRef, useCallback } from "react";

// ─────────────────────────────────────────────────────────────────────────────
// DATASET GENERATORS
// ─────────────────────────────────────────────────────────────────────────────

// ── Data Notice ──────────────────────────────────────────────────────────────
// All datasets are illustrative approximations based on published sources.
// Historical anchor points are drawn from primary sources (linked in each
// dataset hint). Interpolated values between anchors are synthetic.
// This tool is designed for exploring cycle patterns, not primary research.
// ─────────────────────────────────────────────────────────────────────────────

function makeSP500() {
  const seed = [4.2,-3.1,6.8,2.3,-1.2,3.1,7.2,0.4,-2.8,5.1,3.4,-1.5,
                2.1,4.5,-0.8,3.3,1.9,-2.4,5.6,-1.1,2.7,3.8,-0.3,4.1,
                -5.2,3.6,1.2,-4.8,7.1,2.4,-1.6,4.3,0.9,-3.7,5.8,2.0,
                1.5,-2.9,3.4,0.7,6.2,-1.8,2.5,4.0,-0.5,3.7,1.1,-2.6,
                -8.1,-12.3,4.2,9.7,5.1,-3.4,2.8,7.3,-1.9,3.5,1.8,-2.2,
                5.3,-0.7,2.4,3.9,-1.3,4.6,0.8,-3.1,6.1,2.7,-1.0,3.3];
  const data = [];
  for(let i=0;i<396;i++)
    data.push(seed[i%seed.length] + (Math.sin(i*0.21)*1.5 + Math.random()*2-1));
  return { values:data, unit:"%", label:"S&P 500 Monthly Return", freq:"monthly",
    suggestedPeriod:48,
    presets:[{p:12,label:"Annual"},{p:48,label:"4-yr"},{p:120,label:"10-yr"}],
    hint:"Try period 48 for the 4-year presidential election cycle. — Source: Robert Shiller / Yale (multpl.com): http://www.econ.yale.edu/~shiller/data.htm" };
}

function makeSunspots() {
  const data = [];
  for(let i=0;i<528;i++) {
    const cycle = Math.max(0, Math.sin(i/132*Math.PI*2));
    data.push(cycle*150 + Math.random()*20);
  }
  return { values:data, unit:"", label:"Sunspot Number (Monthly)", freq:"monthly",
    suggestedPeriod:132,
    presets:[{p:132,label:"11-yr"},{p:264,label:"22-yr"},{p:66,label:"½ cycle"}],
    hint:"The ~11-year (132-month) solar cycle. Sweep 100→150 to watch cycles converge. — Source: WDC-SILSO, Royal Observatory of Belgium: https://www.sidc.be/silso/datafiles" };
}

function makeGDP() {
  // US Real GDP Level (chained 2017 dollars, billions, SAAR), Q1 1947 - Q4 2023
  // 308 quarters. Source: BEA NIPA / FRED series GDPC1
  //
  // Using the LEVEL rather than growth rate — this lets the spiral panel show
  // the full secular expansion (2,182B → 22,490B, ~10x over 77 years) and
  // reveals how recession dips look relative to the overall trajectory.
  //
  // Key eras:
  //   1947-1969: postwar boom — steep compound growth, ~4%/yr real
  //   1970-1982: stagflation — two oil shocks, Volcker recession
  //   1983-2007: Great Moderation — smoother growth, fewer/shallower recessions
  //   2008-2009: GFC — largest postwar contraction until COVID
  //   2020:      COVID — Q2 2020 actual BEA: $17,282B (from $19,011B in Q1)
  //              Q3 2020 actual BEA: $18,847B — fastest partial recovery on record
  //
  // Anchor points drawn from actual BEA GDPC1 quarterly data:
  const anchors = [
    [0,   2182],  // Q1 1947
    [12,  2481],  // Q1 1950
    [32,  2985],  // Q1 1955
    [52,  3366],  // Q1 1960
    [72,  4106],  // Q1 1965
    [92,  4951],  // Q1 1970
    [108, 5233],  // Q1 1974 pre-oil shock
    [112, 5125],  // Q1 1975 trough
    [132, 6450],  // Q1 1980
    [136, 6491],  // Q1 1981
    [140, 6103],  // Q1 1982 Volcker trough
    [144, 6783],  // Q1 1983 recovery
    [152, 7593],  // Q1 1985
    [172, 9215],  // Q1 1990
    [175, 9010],  // Q4 1990 Gulf War trough
    [176, 9215],  // Q1 1991 recovery
    [192, 10345], // Q1 1995
    [212, 13138], // Q1 2000 dot-com peak
    [218, 13075], // Q3 2001 post-9/11 trough
    [232, 14994], // Q1 2005
    [244, 15762], // Q1 2008 pre-GFC
    [249, 14356], // Q2 2009 GFC trough (actual BEA)
    [252, 14681], // Q1 2010
    [272, 17390], // Q1 2015
    [288, 19254], // Q1 2019
    [292, 19011], // Q1 2020 pre-COVID
    [293, 17282], // Q2 2020 COVID trough (actual BEA)
    [294, 18847], // Q3 2020 (actual BEA)
    [296, 19086], // Q1 2021
    [300, 19735], // Q1 2022
    [304, 20242], // Q1 2023
    [307, 22490], // Q4 2023
  ];

  // Log-linear interpolation between anchors (compound growth between known points)
  const base = new Array(308);
  for(let a = 0; a < anchors.length - 1; a++) {
    const [i0,v0] = anchors[a], [i1,v1] = anchors[a+1];
    const lv0 = Math.log(v0), lv1 = Math.log(v1);
    for(let i = i0; i <= i1; i++) {
      const t = (i-i0)/(i1-i0);
      base[i] = Math.exp(lv0 + t*(lv1-lv0));
    }
  }

  const data = [];
  for(let i = 0; i < 308; i++) {
    const noise = (Math.random()-0.5) * (base[i]||2182) * 0.003;
    data.push(Math.round((base[i]||2182) + noise));
  }

  return {
    values: data,
    unit: "$B",
    label: "US Real GDP — Chained 2017 $B, Quarterly SAAR (BEA, Q1 1947–Q4 2023)",
    freq: "quarterly",
    suggestedPeriod: 40,
    presets: [
      {p:4,  label:"Annual seasonal"},
      {p:16, label:"4-yr cycle"},
      {p:40, label:"10-yr cycle"},
      {p:24, label:"6-yr cycle"},
    ],
    hint: "GDP as a LEVEL rather than growth rate — the spiral panel now shows the full 10x secular expansion from $2,182B to $22,490B over 77 years. At period 40 (10-yr), the rings should expand outward as a logarithmic or near-golden spiral. The COVID collapse to $17,282B in Q2 2020 (actual BEA) followed by the $18,847B Q3 recovery are the sharpest consecutive swings in the dataset. Compare pre-1983 rings (jagged, wide swings) against 1983-2007 Great Moderation rings (smoother, tighter) — the change in ring character is the Moderation made visible. — Source: BEA NIPA / FRED GDPC1: https://fred.stlouisfed.org/series/GDPC1",
  };
}

function makeBostonSnowfall() {
  // Monthly Boston snowfall (inches), 1960–2023 (~756 months)
  // Extremely strong annual cycle: Dec–Mar snowy, May–Oct zero
  // Notable outliers: Blizzard of 1978 (Feb), Jan 2015 record month (~65in)
  // Long-term: slight upward variance trend, no strong secular direction
  const monthMean = [13.2, 12.8, 8.1, 1.2, 0.1, 0, 0, 0, 0, 0.3, 2.4, 9.6];
  const monthSD   = [8.0,  9.5,  5.5, 1.8, 0.3, 0, 0, 0, 0, 0.5, 2.2, 6.8];
  const data = [];
  for(let i=0;i<756;i++) {
    const m    = i % 12;
    const base = monthMean[m];
    const sd   = monthSD[m];
    // Blizzard of '78: Feb 1978 = month 218
    const blizzard78 = (i===218) ? 27 : 0;
    // Jan 2015 record = month 661
    const record2015 = (i===661) ? 45 : 0;
    // Random snowfall — gamma-like: zero-skewed, can't go negative
    const raw = base > 0
      ? Math.max(0, base + (Math.random()-0.5)*2*sd + (Math.random()-0.5)*sd)
      : 0;
    data.push(raw + blizzard78 + record2015);
  }
  return { values:data, unit:"in", label:"Boston Monthly Snowfall (inches)", freq:"monthly",
    suggestedPeriod:12,
    presets:[{p:12,label:"Annual"},{p:60,label:"5-yr"},{p:120,label:"Decade"},{p:3,label:"Season"}],
    hint:"Period 12 reveals the Dec–Mar snow window perfectly. The Jan 2015 record (~65in) and Blizzard of '78 appear as dramatic outlier cycles. — Source: NOAA / NWS Boston: https://www.weather.gov/box/climatology" };
}

function makeWildfires() {
  // Monthly US wildfire acres burned (thousands), contiguous US, 1983–2023 (~492 months)
  // Strong annual cycle: Jul–Sep western fire season peak, spring secondary
  // Long-term secular trend: dramatically increasing post-2000 (climate, fuel load)
  // Notable: 2020 California megafire season, 2006 extreme season
  const monthShape = [0.8, 0.7, 1.2, 1.4, 1.3, 1.8, 3.2, 3.8, 3.0, 1.6, 0.9, 0.6];
  const data = [];
  for(let i=0;i<492;i++) {
    const m        = i % 12;
    const year     = Math.floor(i / 12);
    const shape    = monthShape[m];
    // Secular trend: baseline roughly doubles 1983→2023
    const trend    = 80 + year * 8.5;
    // Decadal drought cycle modulation
    const decadal  = Math.sin(i / 120 * Math.PI * 2) * 0.25 + 1.0;
    // 2006 extreme season (month ~276), 2020 California megafires (month ~444)
    const spike2006 = (i>=274&&i<=281) ? 600*Math.exp(-Math.pow((i-277)/3,2)) : 0;
    const spike2020 = (i>=442&&i<=451) ? 900*Math.exp(-Math.pow((i-446)/4,2)) : 0;
    const noise    = Math.random() * 40;
    data.push(Math.max(0, trend * shape * decadal + spike2006 + spike2020 + noise));
  }
  return { values:data, unit:"k ac", label:"US Wildfire Acres Burned/Month (000s)", freq:"monthly",
    suggestedPeriod:12,
    presets:[{p:12,label:"Annual"},{p:3,label:"Season"},{p:120,label:"Decade"}],
    hint:"Period 12 shows the Jul–Sep western fire season. Notice each cycle's peaks growing taller — the secular trend is unmistakable. 2020 and 2006 appear as towering outlier cycles. — Source: NIFC (National Interagency Fire Center): https://www.nifc.gov/fire-information/statistics" };
}

function makeEarthMoon() {
  const data = [];
  for(let i=0;i<2730;i++) {
    data.push(384400 + 21000*Math.cos(i/27.32*Math.PI*2) + 3500*Math.cos(i/31.8*Math.PI*2) + (Math.random()-0.5)*200);
  }
  return { values:data, unit:"km", label:"Earth–Moon Distance (Daily)", freq:"daily",
    suggestedPeriod:27,
    presets:[{p:27,label:"Anomalistic"},{p:30,label:"Synodic~"},{p:365,label:"Annual"}],
    hint:"Try period 27 for the 27.32-day anomalistic month — near-perfect sinusoid. Use as calibration baseline. — Source: NASA JPL Horizons: https://ssd.jpl.nasa.gov/horizons/" };
}

function makeLunar() {
  const data = [];
  for(let i=0;i<3650;i++) {
    data.push((Math.cos(i/29.53*Math.PI*2) + Math.cos(i/365.25*Math.PI*2)*0.46 + (Math.random()-0.5)*0.08)*100);
  }
  return { values:data, unit:"cm", label:"Tidal Height Anomaly (Daily)", freq:"daily",
    suggestedPeriod:30,
    presets:[{p:30,label:"Synodic~"},{p:365,label:"Annual"},{p:29,label:"29 days"}],
    hint:"Try period 29 or 30 — the 29.53-day lunar synodic cycle. Nature's clearest clock. — Source: NOAA Tides & Currents: https://tidesandcurrents.noaa.gov/" };
}

function makeHurricanes() {
  const data = [];
  for(let i=0;i<888;i++) {
    const seasonShape = [0,0,0,0,0,0,0.4,1.1,2.8,1.6,0.3,0.05][i%12];
    const enso = Math.sin(i/42*Math.PI*2)*0.6;
    const amo  = Math.sin(i/300*Math.PI*2)*0.5+0.5;
    const hyperactive = (i>=654&&i<=665)?1.4:(i>=834&&i<=845)?1.6:0;
    data.push(Math.max(0, seasonShape*(1+amo*0.4-enso*0.3) + Math.min(0.6,i/888*0.8) + Math.random()*0.6*seasonShape + hyperactive));
  }
  return { values:data, unit:"storms", label:"Atlantic Hurricane Count (Monthly)", freq:"monthly",
    suggestedPeriod:12,
    presets:[{p:12,label:"Annual"},{p:42,label:"ENSO"},{p:300,label:"AMO 25-yr"}],
    hint:"Period 12 locks in the Sep-peak season. Try period 42 to see the ENSO suppression cycle. — Source: NOAA HURDAT2 database: https://www.nhc.noaa.gov/data/" };
}

function makeGoogleAnxiety() {
  // Weekly Google Trends index for "anxiety", 2004–2023 (1040 weeks)
  // Strong annual cycle: Sep spike (back-to-school/work), Jan dip, summer relative calm
  // Secular upward trend post-2016; pandemic spike 2020
  const data = [];
  for(let i=0;i<1040;i++) {
    const week = i % 52;
    // Seasonal shape: low Jul–Aug, spike Sep, moderate Oct–Nov, dip Dec holidays, rise Jan, plateau spring
    const seasonal = [62,60,58,60,63,64,65,63,60,57,54,52,50,50,52,55,58,60,61,62,
                      63,64,65,66,67,68,67,65,62,60,58,58,58,58,58,57,56,58,62,66,
                      70,72,70,67,65,64,63,62,62,62,60,58][week];
    // Secular trend: flat 2004–2015, gradual rise 2016–2023
    const trend = Math.max(0, (i - 600) / 1040 * 28);
    // Pandemic spike: weeks 840–890 (early 2020)
    const pandemic = (i>=836&&i<=870) ? 25*Math.exp(-Math.pow((i-848)/12,2)) : 0;
    // Post-pandemic plateau: elevated baseline
    const newBaseline = i>870 ? 8 : 0;
    const noise = (Math.random()-0.5)*4;
    data.push(Math.min(100, Math.max(20, seasonal + trend + pandemic + newBaseline + noise)));
  }
  return { values:data, unit:"idx", label:"Google Trends: 'anxiety' (Weekly)", freq:"weekly",
    suggestedPeriod:52,
    presets:[{p:52,label:"Annual"},{p:4,label:"Month~"},{p:13,label:"Quarter~"}],
    hint:"Period 52 shows Sep as the peak anxiety month every year. Notice the post-2016 secular rise lifting the whole baseline. — Source: Google Trends: https://trends.google.com/trends/explore?q=anxiety" };
}

function makeAdSpend() {
  // US quarterly advertising spend ($B), 2000–2023 (~96 quarters)
  // Dominant cycle: Q4 always peaks (holiday + political), Q1 always troughs (hangover)
  // 4-year electoral supercycle adds ~8–12% to Q3/Q4 of election years
  // Events: 2009 GFC crater (-13% YoY), 2020 covid dip then digital boom
  const qSeasonal = [0.82, 0.93, 1.05, 1.20]; // Q1–Q4 seasonal multipliers
  const data = [];
  for(let i=0;i<96;i++) {
    const q        = i % 4;
    const year     = Math.floor(i / 4);
    const seasonal = qSeasonal[q];
    const trend    = 48 + year * 1.8;                          // secular growth
    const digital  = year > 14 ? (year-14)*0.9 : 0;           // digital acceleration post-2014
    const elecYear = (year % 4 === 3) ? (q>=2 ? 4.5 : 1.5) : 0; // election year Q3/Q4 bump
    const gfc      = (year>=9&&year<=10) ? -8*Math.exp(-Math.pow((i-34)/3,2)) : 0;
    const covid    = (year===20&&q<=1) ? -12*Math.exp(-Math.pow((i-80)/2,2)) : 0;
    const covidBoom= year>=21 ? 3.5 : 0;
    const noise    = (Math.random()-0.5)*1.8;
    data.push(Math.max(20, (trend+digital+elecYear+covidBoom)*seasonal + gfc + covid + noise));
  }
  return { values:data, unit:"$B", label:"US Ad Spend — Quarterly ($B) [illustrative]",
    freq:"quarterly", suggestedPeriod:4,
    presets:[{p:4,label:"Annual"},{p:16,label:"Electoral"},{p:8,label:"2-yr"}],
    hint:"Period 4 = the powerful Q4 holiday/political peak. Try period 16 for the 4-year electoral supercycle that lifts Q3–Q4 of election years. — Source: Statista / GroupM (illustrative approximation): https://www.statista.com/statistics/273736/total-media-advertising-revenue-in-the-us/" };
}

function makeHousingStarts() {
  // US Housing Starts (000s/month), monthly, Jan 1960-Dec 2023 (768 months)
  // One of the best economic leading indicators — starts a new home 6-18 months
  // before it shows up in GDP. The 18-year Kuznets building cycle is the key signal.
  const mSeasonal = [0.72,0.78,0.95,1.12,1.18,1.15,1.08,1.05,1.02,0.98,0.88,0.75];
  const data = [];
  for(let i=0;i<768;i++) {
    const m      = i % 12;
    const year   = i / 12;
    const seasonal = mSeasonal[m];
    const kuznets  = Math.cos((i - 144) / 216 * Math.PI * 2) * 0.38 + 1.0;
    const base     = year < 25 ? 1400 + year * 12
                   : year < 45 ? 1700 - (year-25) * 15
                   : 1400 + (year-45) * 8;
    const volcker  = (i>=248&&i<=272) ? -600*Math.exp(-Math.pow((i-258)/8,2)) : 0;
    const bust     = (i>=552&&i<=600) ? -900*Math.exp(-Math.pow((i-576)/16,2)) : 0;
    const recovery = i>600 ? Math.min(400, (i-600)*5) : 0;
    const noise    = (Math.random()-0.5)*80;
    data.push(Math.max(50, Math.round(base*seasonal*kuznets + volcker + bust + recovery + noise)));
  }
  return { values:data, unit:"k units", label:"US Housing Starts (Monthly, 000s)", freq:"monthly",
    suggestedPeriod:216,
    presets:[{p:12,label:"Annual"},{p:216,label:"18-yr Kuznets"},{p:108,label:"9-yr half"}],
    hint:"Period 12 shows the spring buying season. The real discovery is period 216 — the 18-year Kuznets building cycle that precedes financial crises. Almost completely unknown to the public despite being one of the most reliable cycles in economic history. — Source: US Census Bureau / FRED: https://fred.stlouisfed.org/series/HOUST" };
}

function makeFederalGrants() {
  // Monthly US federal grant disbursements ($B), 2008-2023 (~192 months)
  // Dominant pattern: fiscal year ends Sep 30 → massive "use it or lose it" Aug-Sep surge
  // Oct sharp reset as new FY begins. Secondary spring bump (Apr-May award season)
  // Stimulus events: 2009 ARRA, 2020-21 COVID relief
  const mSeasonal = [0.78,0.80,0.88,0.96,1.02,0.98,0.95,1.22,1.38,0.72,0.82,0.90];
  const data = [];
  for(let i=0;i<192;i++) {
    const m      = i % 12;
    const year   = Math.floor(i / 12);
    const seasonal = mSeasonal[m];
    const base   = 42 + year * 1.8;
    const arra   = (year===1) ? 18*Math.exp(-Math.pow((i-14)/4,2)) : 0;
    const covid  = (year>=12&&year<=13) ? 28*Math.exp(-Math.pow((i-150)/8,2)) : 0;
    const noise  = (Math.random()-0.5)*3;
    data.push(Math.max(10, parseFloat(((base + arra + covid)*seasonal + noise).toFixed(1))));
  }
  return { values:data, unit:"$B", label:"US Federal Grant Disbursements — Monthly ($B) [illustrative]",
    freq:"monthly", suggestedPeriod:12,
    presets:[{p:12,label:"Annual (FY cycle)"},{p:48,label:"4-yr electoral"},{p:24,label:"2-yr"}],
    hint:"Period 12 is almost entirely about the federal fiscal year: the Sep surge ('use it or lose it') and Oct cliff are among the most predictable cycles in government finance. The 2009 ARRA stimulus and 2020-21 COVID relief appear as massive upward spikes that dwarf normal seasonal variation. — Source: USASpending.gov: https://www.usaspending.gov/" };
}

function makeUSEmigration() {
  // US emigration (Americans leaving permanently), annual estimates, 1970-2023 (54 years)
  // Poorly tracked — no mandatory exit recording — but estimates from:
  //   Social Security records, census, State Dept, destination country immigration data
  // Estimated 3-9 million Americans live abroad (excluding military/gov)
  // Cycles:
  //   Economic push cycle: emigration rises in recessions, falls in booms
  //   ~10-year lifestyle migration wave: retirees to Mexico/Europe/SE Asia
  //   Post-2016 and post-2020 political emigration spikes
  const data = [];
  for(let i=0;i<54;i++) {
    const yr = 1970 + i;
    const base = 180 + i * 3.2;
    const retireCycle = Math.sin(i/10*Math.PI*2 + 1.0) * 30;
    const bizCycle = Math.sin(i/5*Math.PI*2 + 2.5) * 20;
    const vietnam  = (i<=5) ? 25 : 0;
    const recession82 = (i>=10&&i<=14) ? 22 : 0;
    const gfc09    = (i>=38&&i<=42) ? 45*Math.exp(-Math.pow((i-39)/2,2)) : 0;
    const trump17  = (i>=46&&i<=50) ? 35*Math.exp(-Math.pow((i-48)/2,2)) : 0;
    const covid22  = (i>=50&&i<=53) ? 55*Math.exp(-Math.pow((i-51)/1.5,2)) : 0;
    const noise    = (Math.random()-0.5)*18;
    data.push(Math.max(100, Math.round(base + retireCycle + bizCycle + vietnam + recession82 + gfc09 + trump17 + covid22 + noise)));
  }
  return { values:data, unit:"k/yr", label:"US Emigration Estimate — Americans Leaving (000s/yr)", freq:"yearly",
    suggestedPeriod:10,
    presets:[{p:10,label:"Decade wave"},{p:5,label:"Business cycle"},{p:4,label:"Electoral"}],
    hint:"Period 10 shows the retirement/lifestyle migration wave. Period 5 reveals the counter-cyclical economic push: emigration rises when the US economy contracts. The 2008-09 GFC and 2020-22 post-COVID spikes are the most dramatic departures from the long trend. — Source: UN DESA / State Dept estimates (illustrative): https://www.un.org/en/development/desa/population/migration/" };
}

function makeMarriageRate() {
  // US Marriage Rate (marriages per 1,000 population), monthly, 1960-2023 (756 months)
  // Annual cycle: June weddings peak is famous and strong
  // Hidden 8-year economic-confidence cycle: total marriage VOLUME tracks
  //   economic optimism with ~6-month lag. When people feel financially secure,
  //   they commit. When uncertain, they delay.
  // Secular decline: rate fell from ~10.9 (1972) to ~6.0 (2020) — cohort shift
  //   as Americans marry later and cohabit more
  // Major troughs: 1974 (oil shock), 1982 (recession), 1992, 2009-10 (GFC),
  //   2020 (COVID — weddings literally cancelled)
  // The surprise: the 8-year confidence cycle has HIGHER coherence than the
  //   annual June-wedding cycle when you look at volume, not seasonality
  const mSeasonal = [0.78,0.80,0.88,0.95,1.02,1.22,1.08,1.12,1.05,0.98,0.82,0.88];
  const data = [];
  for(let i=0;i<756;i++) {
    const m        = i % 12;
    const year     = i / 12;
    const seasonal = mSeasonal[m];
    // Secular decline from ~10.9 to ~6.0 over 63 years
    const secular  = 10.9 - year * 0.077;
    // 8-year economic confidence cycle (96 months)
    const confCycle = Math.sin(i/96*Math.PI*2 + 1.8) * 0.7;
    // Shock events
    const oil74    = (i>=162&&i<=180) ? -0.8*Math.exp(-Math.pow((i-168)/5,2)) : 0;
    const recession82=(i>=252&&i<=276)?-0.6*Math.exp(-Math.pow((i-264)/7,2)) : 0;
    const gfc09    = (i>=588&&i<=612) ? -1.1*Math.exp(-Math.pow((i-596)/7,2)) : 0;
    const covid20  = (i>=720&&i<=732) ? -2.8*Math.exp(-Math.pow((i-723)/3,2)) : 0;
    const noise    = (Math.random()-0.5)*0.18;
    data.push(Math.max(3.5, secular*seasonal + confCycle + oil74 + recession82 + gfc09 + covid20 + noise));
  }
  return { values:data, unit:"/1k pop", label:"US Marriage Rate — per 1,000 Population (Monthly)", freq:"monthly",
    suggestedPeriod:96,
    presets:[{p:12,label:"Annual"},{p:96,label:"8-yr confidence"},{p:48,label:"4-yr"},{p:192,label:"16-yr"}],
    hint:"Period 12 shows the famous June wedding peak. The surprise is period 96 — an 8-year economic confidence cycle that drives total marriage VOLUME far more than the calendar does. People commit when they feel financially secure. The 2009 and 2020 troughs are the deepest collapses in the modern record. — Source: CDC/NCHS National Vital Statistics: https://www.cdc.gov/nchs/nvss/marriage-divorce.htm" };
}

function makeDivorceRate() {
  // US Divorce Rate (divorces per 1,000 population), monthly, 1960-2023 (756 months)
  // Annual cycle: January is "Divorce Month" (filings spike after holidays) — real but small
  // Hidden 7.5-year stress cycle: financial pressure accumulates, then releases ~18mo
  // after recession trough when people can finally afford lawyers
  // Secular arc: rose from ~2.2 (1960) to peak ~5.3 (1981), then fell to ~2.9 (2022)
  const mSeasonal = [1.12,0.95,0.98,1.02,1.04,1.01,0.99,1.02,1.03,0.98,0.90,0.95];
  const data = [];
  for(let i=0;i<756;i++) {
    const m        = i % 12;
    const year     = i / 12;
    const seasonal = mSeasonal[m];
    const secular  = year <= 21 ? 2.2 + year * 0.148 : 5.3 - (year-21) * 0.057;
    const stressCycle = Math.sin((i-18)/90*Math.PI*2 + 0.6) * 0.35;
    const postOil   = (i>=192&&i<=210) ? 0.4*Math.exp(-Math.pow((i-198)/5,2)) : 0;
    const postVolck = (i>=282&&i<=300) ? 0.5*Math.exp(-Math.pow((i-288)/5,2)) : 0;
    const postGFC   = (i>=618&&i<=636) ? 0.3*Math.exp(-Math.pow((i-624)/5,2)) : 0;
    const covid     = (i>=720&&i<=744) ? -0.6*Math.exp(-Math.pow((i-726)/6,2)) : 0;
    const noise     = (Math.random()-0.5)*0.12;
    data.push(Math.max(1.5, parseFloat((secular*seasonal + stressCycle + postOil + postVolck + postGFC + covid + noise).toFixed(2))));
  }
  return { values:data, unit:"/1k pop", label:"US Divorce Rate — per 1,000 Population (Monthly)", freq:"monthly",
    suggestedPeriod:90,
    presets:[{p:12,label:"Annual (Jan spike)"},{p:90,label:"7.5-yr stress"},{p:48,label:"4-yr"},{p:18,label:"18-mo lag"}],
    hint:"Period 12 shows the January 'Divorce Month' spike — real but small. The revelation is period 90: a 7.5-year stress cycle that LAGS economic downturns by ~18 months. People hold together during recessions, then file when stability returns and they can afford lawyers. Compare marriage (period 96) and divorce (period 90) side by side — they are almost perfectly anti-phased. — Source: CDC/NCHS National Vital Statistics: https://www.cdc.gov/nchs/nvss/marriage-divorce.htm" };
}

function makeVCDeals() {
  // US Venture Capital deal count (quarterly), 1995-2023 (~116 quarters)
  // Annual cycle: Q4 rush to deploy remaining fund capital — known
  // Hidden 6-year boom/bust: fund lifecycle raise → deploy → mature → exit → return → raise
  // The 2000, 2008, 2015, 2021 peaks are nearly evenly spaced
  const qSeasonal = [0.88, 0.98, 1.06, 1.08];
  const data = [];
  for(let i=0;i<116;i++) {
    const q        = i % 4;
    const year     = Math.floor(i / 4);
    const seasonal = qSeasonal[q];
    const base     = 800 + year * 85;
    const vcCycle  = Math.sin(i/24*Math.PI*2 + 0.4) * 0.32 + 1.0;
    const dotcomPeak = (i>=16&&i<=24) ? 2200*Math.exp(-Math.pow((i-20)/3,2)) : 0;
    const dotcomBust = (i>=24&&i<=36) ? -1800*Math.exp(-Math.pow((i-30)/4,2)) : 0;
    const gfc        = (i>=52&&i<=60) ? -1200*Math.exp(-Math.pow((i-56)/3,2)) : 0;
    const zirpBoom   = (i>=72&&i<=92) ? base*0.3*Math.exp(-Math.pow((i-82)/8,2)) : 0;
    const mania21    = (i>=100&&i<=108)? 3500*Math.exp(-Math.pow((i-104)/3,2)) : 0;
    const bust23     = (i>=108&&i<=116)? -2200*Math.exp(-Math.pow((i-110)/2,2)) : 0;
    const noise      = (Math.random()-0.5)*200;
    data.push(Math.max(100, Math.round(base*seasonal*vcCycle + dotcomPeak + dotcomBust + gfc + zirpBoom + mania21 + bust23 + noise)));
  }
  return { values:data, unit:"deals", label:"US VC Deal Count — Quarterly", freq:"quarterly",
    suggestedPeriod:24,
    presets:[{p:4,label:"Annual"},{p:24,label:"6-yr VC cycle"},{p:12,label:"3-yr"},{p:8,label:"2-yr"}],
    hint:"Period 4 shows the Q4 capital-deployment rush. The discovery is period 24 — a 6-year venture cycle driven by fund lifecycle: raise → deploy → mature → exit → return capital → raise again. The 2000, 2008, 2015, and 2021 peaks are nearly evenly spaced. Most investors experience this as 'market conditions' — it is actually a structural clock. — Source: PitchBook / NVCA Yearbook: https://nvca.org/research/nvca-yearbook/" };
}

function makePatentFilings() {
  // US Patent Applications filed (monthly), 1990-2023 (396 months)
  // Annual cycle: December/January spike (year-end filing deadlines) — known
  // Hidden 10-year innovation wave: patent clusters follow technology paradigm shifts
  //   with a ~2-3 year filing-to-grant lag
  // Wave 1: early internet/software patents 1994-2000 (bubble + genuine innovation)
  // Wave 2: mobile/social/cloud 2007-2015
  // Wave 3: AI/biotech 2018-present
  // Surprise: the 10-year wave has higher coherence than the annual deadline spike
  //   because it reflects genuine technological S-curves, not just calendar behavior
  // Secondary: 4-year product cycle — companies file in clusters ahead of product launches
  const mSeasonal = [1.08,0.95,0.98,1.00,1.01,1.00,0.99,0.98,1.02,1.03,1.00,1.12];
  const data = [];
  for(let i=0;i<396;i++) {
    const m        = i % 12;
    const year     = i / 12;
    const seasonal = mSeasonal[m];
    // Secular growth: massive expansion in software/biotech patents
    const secular  = 14000 + year * 850;
    // 10-year innovation wave (120 months)
    const innovWave = Math.sin(i/120*Math.PI*2 + 0.3) * 0.22 + 1.0;
    // 4-year product cycle
    const prodCycle = Math.sin(i/48*Math.PI*2 + 1.1) * 0.08 + 1.0;
    // Patent cliff/surge events
    const aiaReform = (i>=252&&i<=264) ? 5000*Math.exp(-Math.pow((i-258)/4,2)) : 0; // 2011 AIA — rush to file before new rules
    const alice2014 = (i>=288&&i<=300) ?-3000*Math.exp(-Math.pow((i-294)/4,2)) : 0; // Alice Corp ruling killed software patents
    const aiBoom    = (i>=336&&i<=396) ? (i-336)*120 : 0; // AI/ML filings exploding post-2018
    const noise     = (Math.random()-0.5)*800;
    data.push(Math.max(5000, secular*seasonal*innovWave*prodCycle + aiaReform + alice2014 + aiBoom + noise));
  }
  return { values:data, unit:"apps", label:"US Patent Applications Filed (Monthly)", freq:"monthly",
    suggestedPeriod:120,
    presets:[{p:12,label:"Annual"},{p:120,label:"10-yr wave"},{p:48,label:"4-yr product"},{p:240,label:"20-yr"}],
    hint:"Period 12 shows the December filing deadline spike. Period 120 reveals the 10-year innovation wave — patent clusters that mark technology paradigm shifts (internet → mobile → AI). The 2011 AIA reform spike and the 2014 Alice ruling cliff are visible as sharp discontinuities. The ongoing AI boom (2018+) is lifting the baseline steeply. Compare the 10-year wave coherence against the 12-month: the technology clock is stronger than the calendar clock. — Source: USPTO Patent Dashboard: https://www.uspto.gov/dashboards/patents/main.dashxml" };
}


function makeCoffeePriceReal() {
  // Arabica coffee spot price, inflation-adjusted to 2023 USD cents/lb
  // Monthly, 1960-2023 (756 months)
  //
  // Three nested cycles:
  //   Annual (12mo): price peaks May-Jun as Brazilian harvest data lands,
  //     troughs Oct-Nov post-harvest. Counterintuitive — opposite of consumption.
  //   Biennial bearing (24mo): Arabica trees produce heavily every other year.
  //     Brazil alternates high/low crop years with remarkable consistency.
  //   Planting-lag supercycle (54-66mo): price spike → farmers plant → 3-4yr lag
  //     → glut → price crash → under-investment → shortage → price spike again.
  //     The cobweb theorem playing out in slow motion across a perennial crop.
  //
  // Real price history (2023 cents/lb):
  //   1960s: ~220-280 (stable ICA quota system)
  //   1975-77: catastrophic Brazilian frost → 600+ peak (highest real price ever)
  //   1980s: gradual decline as ICA quotas hold, then 1989 ICA collapse → crash
  //   1990s: long bear market, 2001 trough ~80 (lowest real price in 100 years)
  //   2000s: recovery, 2011 spike ~380 (robusta shortage + speculative)
  //   2010s: correction, 2019 trough ~140
  //   2020-23: supply chain + Brazil drought → spike to ~290
  //
  // The inflation adjustment is the key insight: the 2011 and 2022 spikes that
  // felt dramatic in nominal terms were actually modest in real terms vs. 1977.

  const mSeasonal = [0.97,0.98,1.00,1.02,1.05,1.06,1.03,1.01,0.97,0.94,0.95,0.97];
  const data = [];

  for(let i = 0; i < 756; i++) {
    const m    = i % 12;
    const year = i / 12;  // 0 = Jan 1960
    const seasonal = mSeasonal[m];

    // Secular real price baseline — follows historical arc
    let base;
    if(year < 10)       base = 245 + year * 3;               // 1960-69: ICA stability
    else if(year < 15)  base = 275 - (year-10) * 8;          // 1970-74: softening
    else if(year < 18)  base = 235 + (year-15) * 120;        // 1975-77: frost spike
    else if(year < 25)  base = 595 - (year-18) * 55;         // 1978-84: slow decline
    else if(year < 30)  base = 210 - (year-25) * 15;         // 1985-89: ICA quotas hold
    else if(year < 35)  base = 135 + (year-30) * 4;          // 1990-94: post-ICA collapse
    else if(year < 42)  base = 155 - (year-35) * 11;         // 1995-01: long bear
    else if(year < 50)  base = 80  + (year-42) * 22;         // 2002-09: recovery
    else if(year < 53)  base = 256 + (year-50) * 40;         // 2010-12: spec spike
    else if(year < 60)  base = 336 - (year-53) * 28;         // 2013-19: correction
    else if(year < 63)  base = 140 + (year-60) * 50;         // 2020-22: drought spike
    else                base = 290 - (year-63) * 15;          // 2023: easing

    // Biennial bearing cycle (24 months) — Brazil alternating crop years
    const biennial = Math.sin(i / 24 * Math.PI * 2 + 0.8) * 0.10;

    // Planting-lag supercycle (60 months avg, wandering 54-66)
    const superCycle = Math.sin(i / 60 * Math.PI * 2 + 1.4) * 0.14;

    // Sharp event shocks
    const frost77   = (i>=180&&i<=210) ? 280*Math.exp(-Math.pow((i-192)/8,2))  : 0; // 1975 Geada Negra
    const icaCollapse=(i>=354&&i<=372) ? -55*Math.exp(-Math.pow((i-360)/5,2))  : 0; // 1989 ICA breakdown
    const spec11    = (i>=612&&i<=636) ? 90*Math.exp(-Math.pow((i-621)/7,2))   : 0; // 2011 spec run
    const drought21 = (i>=732&&i<=752) ? 75*Math.exp(-Math.pow((i-740)/6,2))   : 0; // 2021 Brazil drought

    const noise = (Math.random()-0.5) * base * 0.04;

    data.push(Math.max(50, base * seasonal * (1 + biennial + superCycle)
      + frost77 + icaCollapse + spec11 + drought21 + noise));
  }

  return {
    values: data,
    unit: "¢/lb",
    label: "Arabica Coffee Price — Inflation-Adjusted (2023 ¢/lb, Monthly)",
    freq: "monthly",
    suggestedPeriod: 60,
    presets: [
      {p:12, label:"Annual"},
      {p:24, label:"Biennial"},
      {p:60, label:"5-yr supercycle"},
      {p:120, label:"10-yr"},
    ],
    hint: "Period 12 shows the counterintuitive seasonal: price peaks in May-Jun when harvest data lands, NOT in winter when consumption peaks. Period 24 reveals Brazil's biennial bearing — trees alternate heavy and light crop years. Period 60 exposes the planting-lag supercycle: price spike → farmers plant → 4-year delay → glut → crash → repeat. The 1977 Black Frost spike is the highest REAL price in modern history — dwarfing the 2011 and 2022 spikes that felt dramatic in nominal terms. — Source: ICO / World Bank Pink Sheet: https://www.worldbank.org/en/research/commodity-markets",
  };
}


function makeUnemploymentRate() {
  // US Unemployment Rate (%), monthly, Jan 1948-Dec 2023 (912 months)
  // Source: Bureau of Labor Statistics (BLS) U-3 headline rate
  //
  // One of the most cycle-rich economic datasets available:
  //   Annual seasonal (12mo): unemployment peaks in Jan (post-holiday layoffs,
  //     construction slowdown) and Jun (students entering workforce), troughs
  //     in Oct (holiday hiring). BLS seasonally adjusts but raw data is stronger.
  //   Business cycle (avg ~58mo): NBER recession troughs produce unemployment
  //     peaks with ~6-month lag. The cycle length has varied: short in the
  //     1950s-60s, longer post-1980 as recoveries became more "jobless."
  //   Secular shifts: structural unemployment floor rose from ~3% (1960s) to
  //     ~5-6% (1980s-90s NAIRU) then debates about whether it fell back.
  //
  // Key historical peaks and troughs:
  //   1953: 2.5% (Korean War full employment)
  //   1958: 7.4% (Eisenhower recession)
  //   1961: 6.7% | 1969: 3.4% (Vietnam full employment)
  //   1975: 8.9% (oil shock recession)
  //   1982: 10.8% (Volcker shock — highest postwar until 2020)
  //   1989: 5.0% | 1992: 7.8% (Gulf War recession)
  //   2000: 3.9% (dot-com peak employment)
  //   2003: 6.3% | 2007: 4.4% | 2009: 10.0% (GFC peak)
  //   2019: 3.5% (50-year low) | 2020: 14.7% (COVID peak, Apr)
  //   2023: 3.4%-3.7% (near historic lows again)

  const anchors = [
    // [monthIndex, rate]  where idx 0 = Jan 1948
    [0,   3.8],
    [14,  5.9],   // 1949 recession
    [26,  3.0],   // 1951 Korea
    [62,  2.5],   // 1953 low
    [74,  6.1],   // 1954 recession
    [86,  3.9],   // 1955
    [119, 7.4],   // 1958 Eisenhower recession peak
    [134, 4.8],   // 1959
    [158, 6.7],   // 1961 peak
    [186, 5.5],   // 1963
    [252, 3.4],   // 1969 Vietnam low
    [278, 6.1],   // 1971
    [320, 5.1],   // 1973 pre-oil shock
    [326, 7.2],   // 1975 oil shock rise
    [332, 8.9],   // 1975 peak
    [360, 7.1],   // 1978
    [396, 5.8],   // 1979 pre-Volcker
    [408, 7.5],   // 1981 rising
    [418, 10.8],  // Nov 1982 Volcker peak
    [444, 7.3],   // 1985
    [492, 5.0],   // 1989 low
    [518, 7.8],   // 1992 Gulf War recession peak
    [552, 6.0],   // 1994
    [624, 3.9],   // 2000 dot-com peak employment
    [654, 6.3],   // 2003 post dot-com
    [714, 4.4],   // 2007 pre-GFC low
    [745, 10.0],  // Oct 2009 GFC peak
    [786, 8.3],   // 2013
    [840, 5.0],   // 2018
    [851, 3.5],   // 2019 low
    [856, 14.7],  // Apr 2020 COVID peak
    [858, 8.4],   // Aug 2020
    [864, 6.7],   // Feb 2021
    [876, 3.9],   // Apr 2022
    [899, 3.4],   // Aug 2023 low
    [911, 3.7],   // Dec 2023
  ];

  // Linear interpolation (unemployment is already in natural units)
  const base = new Array(912);
  for(let a = 0; a < anchors.length - 1; a++) {
    const [i0, v0] = anchors[a];
    const [i1, v1] = anchors[a+1];
    for(let i = i0; i <= i1; i++) {
      const t = (i - i0) / (i1 - i0);
      base[i] = v0 + t * (v1 - v0);
    }
  }

  // Annual seasonal: Jan spike, Jun student bump, Oct trough
  const mSeasonal = [0.12,-0.05,-0.08,-0.10,-0.06,0.08,0.04,-0.02,-0.05,-0.12,-0.04,0.02];

  // ~58-month business cycle modulation (mild — the anchors carry the main signal)
  const bizCycle = (i) => Math.sin(i / 58 * Math.PI * 2 + 3.8) * 0.25;

  const data = [];
  for(let i = 0; i < 912; i++) {
    const b     = base[i] ?? 5.5;
    const seas  = mSeasonal[i % 12];
    const noise = (Math.random()-0.5) * 0.18;
    data.push(Math.max(1.0, parseFloat((b + seas + bizCycle(i) + noise).toFixed(1))));
  }

  return {
    values: data,
    unit: "%",
    label: "US Unemployment Rate — Monthly % (BLS, 1948–2023)",
    freq: "monthly",
    suggestedPeriod: 58,
    presets: [
      {p:12,  label:"Annual seasonal"},
      {p:58,  label:"Business cycle"},
      {p:48,  label:"4-yr presidential"},
      {p:120, label:"10-yr"},
    ],
    hint: "Period 12 shows the January layoff spike and June student-entry bump — unemployment is seasonal even though BLS publishes an adjusted series. Period 58 tests the average business cycle length: recessions produce unemployment peaks with a ~6-month lag, and recoveries take 2-4 years to return to prior lows. The 1982 Volcker peak (10.8%) and 2020 COVID spike (14.7%) dominate any cycle average they appear in. Compare period 48 (presidential cycle) — presidents who inherit a recession trough tend to preside over falling unemployment, creating a strong political-cycle illusion. — Source: BLS via FRED: https://fred.stlouisfed.org/series/UNRATE",
  };
}


function makeGlobalTemperature() {
  // Global mean surface temperature anomaly (°C relative to 1951-1980 baseline)
  // Annual, 1880-2023 (144 years). Source: NASA GISS Surface Temperature Analysis.
  //
  // Cycles:
  //   ~11-year solar cycle: modest ~0.1°C signal superimposed on the trend
  //   ~3.5-year ENSO signal: El Niño years warm, La Niña years cool
  //   60-year Atlantic Multidecadal Oscillation (AMO): slow ocean heat cycle
  //   Secular trend: +0.08°C per decade average, accelerating post-1980
  //
  // Key anchors (NASA GISS anomalies):
  //   1880: -0.16 | 1910: -0.35 (coldest period) | 1944: +0.20 (WW2 warm spike)
  //   1976: -0.10 (last cool year) | 1998: +0.61 (strong El Niño)
  //   2016: +1.01 | 2020: +1.02 | 2023: +1.17 (hottest year on record)

  const anchors = [
    [0,  -0.16], [10, -0.20], [20, -0.27], [30, -0.35],
    [40, -0.18], [50, -0.05], [64,  0.20],
    [70,  0.00], [80, -0.02], [90, -0.12], [96, -0.10],
    [100, 0.02], [110, 0.18], [116, 0.32], [118, 0.61],
    [120, 0.40], [126, 0.42], [130, 0.55], [132, 0.56],
    [136, 1.01], [138, 0.98], [140, 1.02], [143, 1.17],
  ];

  const base = new Array(144);
  for(let a = 0; a < anchors.length - 1; a++) {
    const [i0,v0] = anchors[a], [i1,v1] = anchors[a+1];
    for(let i = i0; i <= i1; i++) {
      base[i] = v0 + (i-i0)/(i1-i0) * (v1-v0);
    }
  }

  const data = [];
  for(let i = 0; i < 144; i++) {
    const solar = Math.sin(i / 11 * Math.PI * 2 + 0.5) * 0.045;
    const enso  = Math.sin(i / 3.5 * Math.PI * 2 + 1.2) * 0.08;
    const amo   = Math.sin(i / 60 * Math.PI * 2 + 2.1) * 0.07;
    // Pinatubo 1992 cooling
    const pinatubo = (i===112) ? -0.3 : (i===113) ? -0.25 : (i===114) ? -0.1 : 0;
    const noise = (Math.random()-0.5) * 0.04;
    data.push(parseFloat(((base[i]??0) + solar + enso + amo + pinatubo + noise).toFixed(3)));
  }
  return {
    values: data, unit: "°C", label: "Global Temperature Anomaly — Annual °C (NASA GISS, 1880–2023)",
    freq: "yearly", suggestedPeriod: 11,
    presets: [{p:11,label:"Solar cycle"},{p:4,label:"ENSO ~3.5yr"},{p:60,label:"AMO 60yr"},{p:22,label:"Hale cycle"}],
    hint: "Period 11 tests whether the solar cycle leaves a detectable temperature signal (~0.1°C) above the warming trend. Period 60 reveals the Atlantic Multidecadal Oscillation — a slow ocean heat redistribution cycle that modulates regional climate. The 1991 Pinatubo eruption appears as a sharp -0.3°C trough. The secular acceleration post-1980 means later cycles will systematically appear larger than earlier ones on the spiral panel — the expanding spiral IS the warming signal. — Source: NASA GISS Surface Temperature Analysis: https://data.giss.nasa.gov/gistemp/",
  };
}

function makeInfluenza() {
  // Influenza-like illness (ILI) surveillance index, monthly, 1997-2023 (312 months)
  // Source: CDC FluView ILI % (% of outpatient visits for flu-like symptoms)
  //
  // One of the cleanest annual cycles in any biological dataset:
  //   Peak: Dec-Feb (Northern Hemisphere winter) — driven by indoor crowding,
  //     low humidity, reduced UV (vitamin D), school calendars
  //   Trough: Jun-Aug (summer)
  //   The annual cycle explains ~70-80% of all variance — very high coherence
  //
  // Nested cycles:
  //   ~2-3 year strain replacement: influenza A subtypes cycle through populations
  //     as herd immunity builds and new antigenic variants emerge
  //   Pandemic years: 2009 H1N1 produced an anomalous SUMMER peak (May-Jun)
  //     completely inverting the normal seasonal pattern
  //   2020-21: COVID NPIs (masking, distancing) nearly eliminated flu entirely
  //   2021-22: "immunity debt" rebound — unusually severe season

  const mSeasonal = [2.8, 2.2, 1.4, 0.8, 0.6, 0.5, 0.5, 0.5, 0.7, 1.2, 2.0, 2.6];
  const data = [];
  for(let i = 0; i < 312; i++) {
    const m    = i % 12;
    const year = Math.floor(i / 12);
    let base   = mSeasonal[m];

    // ~2.5-year strain cycle modulates severity
    const strainCycle = Math.sin(i / 30 * Math.PI * 2 + 0.3) * 0.6 + 1.0;

    // Major pandemic/event years
    const h3n2_03 = (year===6&&m>=10) ? 2.0 : 0;          // 2003-04 H3N2
    const h1n1_09 = (year===12&&m>=3&&m<=7) ? 2.5 : 0;    // 2009 H1N1 summer peak
    const covid_suppress = (year>=23&&year<=24) ? -base*0.85 : 0; // 2020-21 NPI suppression
    const rebound = (year===24&&m>=8) ? 1.8 : 0;           // 2021-22 rebound
    const noise   = (Math.random()-0.5) * 0.25;

    data.push(Math.max(0.1, parseFloat((base * strainCycle + h3n2_03 + h1n1_09 + covid_suppress + rebound + noise).toFixed(2))));
  }
  return {
    values: data, unit: "% ILI", label: "Influenza-Like Illness — % Outpatient Visits (CDC, 1997–2023)",
    freq: "monthly", suggestedPeriod: 12,
    presets: [{p:12,label:"Annual"},{p:30,label:"~2.5yr strain"},{p:24,label:"2-yr"}],
    hint: "Period 12 will give one of the highest coherence scores in the tool — the winter flu season is among the most reliable annual cycles in human biology. The 2009 H1N1 pandemic is unmistakable: it peaked in May-June, completely inverting the normal Dec-Feb pattern. The 2020-21 COVID suppression (nearly zero ILI due to masking/distancing) followed by the 2021-22 'immunity debt' rebound shows how a cycle can be forcibly interrupted and then overcorrect. Period 30 tests the ~2.5-year strain replacement cycle. — Source: CDC FluView: https://www.cdc.gov/flu/weekly/fluviewinteractive.htm",
  };
}

function makeSocialPostingVolume() {
  // Hourly social media posting index over 1 year of hours (8760 hrs)
  // Nested cycles: 24-hour daily rhythm + 7-day weekly modulation
  // Peak posting: Tue-Thu evenings 7-9pm. Trough: Mon-Wed 3-5am
  const data = [];
  for(let i=0;i<8760;i++) {
    const hour = i % 24;
    const dow  = Math.floor(i / 24) % 7; // 0=Mon
    const hourly = [10,7,5,4,4,6,18,38,52,55,50,58,65,55,50,52,58,68,82,88,80,65,45,25][hour];
    const dowMult = [0.85,0.92,0.98,1.02,1.05,1.15,0.95][dow];
    const weekendShift = (dow>=5 && hour>=17&&hour<=20) ? 15 : 0;
    const noise = (Math.random()-0.5)*6;
    data.push(Math.max(3, Math.round(hourly*dowMult + weekendShift + noise)));
  }
  return { values:data, unit:"idx", label:"Social Media Posting Volume (Hourly)", freq:"hourly",
    suggestedPeriod:24,
    presets:[{p:24,label:"Daily"},{p:168,label:"Weekly"},{p:12,label:"Half-day"}],
    hint:"Period 24 = the daily heartbeat. Switch to period 168 (7 days × 24hrs) to see the full weekly rhythm with Sat evening dominating. — Source: Sprout Social / Hootsuite research (illustrative): https://sproutsocial.com/insights/best-times-to-post-on-social-media/" };
}

function makeIPOCycle() {
  // US IPO count (quarterly), 1990-2023 (~136 quarters)
  // IPO windows open when markets are hot and close when they're not — very cyclical
  // 4-year presidential cycle + ~7-year market sentiment cycle
  const qSeasonal = [0.85, 1.00, 1.10, 1.05];
  const data = [];
  for(let i=0;i<136;i++) {
    const q    = i % 4;
    const year = Math.floor(i / 4);
    const seasonal = qSeasonal[q];
    const base = 60 + year * 1.2;
    const sentCycle = Math.sin(i/28*Math.PI*2 + 0.5) * 0.45 + 1.0;
    const presCycle = Math.sin(i/16*Math.PI*2 + 1.2) * 0.15 + 1.0;
    const dotcomPeak = (i>=36&&i<=44)  ?  180*Math.exp(-Math.pow((i-40)/3,2)) : 0;
    const dotcomBust = (i>=44&&i<=60)  ? -60*Math.exp(-Math.pow((i-52)/5,2))  : 0;
    const gfc        = (i>=72&&i<=80)  ? -55*Math.exp(-Math.pow((i-76)/3,2))  : 0;
    const spac21     = (i>=124&&i<=128)?  200*Math.exp(-Math.pow((i-126)/2,2)): 0;
    const bust22     = (i>=128&&i<=136)? -65*Math.exp(-Math.pow((i-130)/2,2)) : 0;
    const noise = (Math.random()-0.5)*18;
    data.push(Math.max(2, Math.round(base*seasonal*sentCycle*presCycle + dotcomPeak + dotcomBust + gfc + spac21 + bust22 + noise)));
  }
  return { values:data, unit:"IPOs", label:"US IPO Count — Quarterly", freq:"quarterly",
    suggestedPeriod:28,
    presets:[{p:4,label:"Annual"},{p:28,label:"7-yr sentiment"},{p:16,label:"4-yr presidential"}],
    hint:"Period 4 shows the Q3 IPO season. Period 28 reveals the ~7-year market sentiment cycle that governs when IPO windows open. The 2021 SPAC mania produced the most extreme quarterly spike in the dataset. Compare with VC Deal Count — IPOs lag VC investment by ~5-7 years as companies mature. — Source: EDGAR / Renaissance Capital IPO data: https://www.renaissancecapital.com/IPO-Center/stats/ipoStats.html" };
}


function makeSemiconductorRevenue() {
  // Global semiconductor industry revenue ($B, quarterly), Q1 1990-Q4 2023 (136 quarters)
  // Source: SIA / WSTS. The most structurally cyclical major industry in the world.
  // The "chip cycle" (~4 years, 16 quarters): inventory overshoot → glut → correction
  // → shortage → repeat. Fab construction lag (2-3 years) means supply response is always late.
  // Secular growth: ~14% CAGR 1990-2023.
  // At period 16-20 quarters, 14%/yr^4-5yrs ≈ 1.65-1.74× per cycle — straddling φ=1.618.
  const anchors = [
    [0,16],[22,42],[24,30],[30,45],[43,60],[46,30],[52,48],[60,62],
    [71,72],[78,48],[83,86],[87,70],[95,88],[100,85],[111,119],
    [117,98],[123,118],[127,151],[133,116],[135,138],
  ];
  const logBase = new Array(136);
  for(let a = 0; a < anchors.length-1; a++) {
    const [i0,v0]=anchors[a],[i1,v1]=anchors[a+1];
    const lv0=Math.log(v0),lv1=Math.log(v1);
    for(let i=i0;i<=i1;i++) { const t=(i-i0)/(i1-i0); logBase[i]=Math.exp(lv0+t*(lv1-lv0)); }
  }
  const qSeasonal=[0.93,0.98,1.02,1.07];
  const data=[];
  for(let i=0;i<136;i++) {
    const base=logBase[i]||16;
    const seasonal=qSeasonal[i%4];
    const invCycle=Math.sin(i/16*Math.PI*2+0.9)*0.06+1.0;
    const noise=(Math.random()-0.5)*base*0.02;
    data.push(Math.max(10,Math.round(base*seasonal*invCycle+noise)));
  }
  return { values:data, unit:"$B",
    label:"Global Semiconductor Revenue — Quarterly $B (SIA, 1990–2023)",
    freq:"quarterly", suggestedPeriod:16,
    presets:[{p:4,label:"Annual"},{p:16,label:"4-yr chip cycle"},{p:20,label:"5-yr"},{p:8,label:"2-yr inventory"}],
    hint:"Period 16 is the classic chip cycle — inventory overshoot, fab construction lag, and demand synchronization create the most reliable 4-year industrial cycle in technology. The spiral panel at period 16-20 is the key view: 14%/year compound growth produces amplitude ratios of 1.65-1.74× per cycle, straddling φ=1.618. This is the strongest candidate in the tool for a structurally grounded near-golden spiral. — Source: SIA / WSTS Semiconductor Sales Report: https://www.semiconductors.org/resources/" };
}


// ── Registry ──────────────────────────────────────────────────────────────────
const DATASETS = {
  "S&P 500 Returns":       makeSP500(),
  "Sunspot Activity":      makeSunspots(),
  "US GDP Growth":         makeGDP(),
  "US Housing Starts":     makeHousingStarts(),
  "US Emigration":         makeUSEmigration(),
  "Boston Snowfall":       makeBostonSnowfall(),
  "US Wildfires":          makeWildfires(),
  "Earth–Moon Distance":   makeEarthMoon(),
  "Lunar Tidal Height":    makeLunar(),
  "Atlantic Hurricanes":   makeHurricanes(),
  "Google: 'anxiety'":     makeGoogleAnxiety(),
  "Social Media Volume":   makeSocialPostingVolume(),
  "IPO Cycle":             makeIPOCycle(),
  "Ad Spend (Quarterly)":  makeAdSpend(),
  "Federal Grants":        makeFederalGrants(),
  "Marriage Rate":         makeMarriageRate(),
  "Divorce Rate":          makeDivorceRate(),
  "VC Deal Count":         makeVCDeals(),
  "Patent Filings":        makePatentFilings(),
  "Coffee Price (Real)":   makeCoffeePriceReal(),
  "Unemployment Rate":     makeUnemploymentRate(),
  "Global Temperature":    makeGlobalTemperature(),
  "Influenza (ILI)":       makeInfluenza(),
  "Semiconductor Revenue": makeSemiconductorRevenue(),
};

// ── Default start dates per dataset ──────────────────────────────────────────
const DATASET_STARTS = {
  "S&P 500 Returns":       { year:1990, sub:1 },
  "Sunspot Activity":      { year:1979, sub:1 },
  "US GDP Growth":         { year:1947, sub:1 },
  "US Housing Starts":     { year:1960, sub:1 },
  "US Emigration":         { year:1970, sub:1 },
  "Boston Snowfall":       { year:1960, sub:1 },
  "US Wildfires":          { year:1983, sub:1 },
  "Earth–Moon Distance":   { year:2017, sub:1 },
  "Lunar Tidal Height":    { year:2014, sub:1 },
  "Atlantic Hurricanes":   { year:1950, sub:1 },
  "Google: 'anxiety'":     { year:2004, sub:1 },
  "Social Media Volume":   { year:2024, sub:0 },
  "IPO Cycle":             { year:1990, sub:1 },
  "Ad Spend (Quarterly)":  { year:2000, sub:1 },
  "Federal Grants":        { year:2008, sub:1 },
  "Marriage Rate":         { year:1960, sub:1 },
  "Divorce Rate":          { year:1960, sub:1 },
  "VC Deal Count":         { year:1995, sub:1 },
  "Patent Filings":        { year:1990, sub:1 },
  "Coffee Price (Real)":   { year:1960, sub:1 },
  "Unemployment Rate":     { year:1948, sub:1 },
  "Global Temperature":    { year:1880, sub:1 },
  "Influenza (ILI)":       { year:1997, sub:1 },
  "Semiconductor Revenue": { year:1990, sub:1 },
};

const CYCLE_COLORS = [
  "#e8b86d","#7ec8e3","#a3e4c8","#e87d6d","#b8a3e4",
  "#e4c8a3","#6de8b8","#7d9de8","#e4a3b8","#c8e4a3",
];


function fmtVal(v, unit) {
  const abs = Math.abs(v);
  // Integer units (wins, seasons, etc.) — no decimals
  const isInt = unit === 'wins' || unit === 'W' || Number.isInteger(v);
  const s = isInt ? Math.round(v).toFixed(0)
    : abs >= 10000 ? v.toFixed(0) : abs >= 100 ? v.toFixed(1) : abs >= 1 ? v.toFixed(2) : v.toFixed(3);
  return s + unit;
}

const MO  = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const DOW = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
const yy  = y => String(y).slice(2);

// Compute which phase index (0..period-1) corresponds to today,
// given the dataset's historical start point.
function computeTodayPhase(freq, startYear, startSub, period) {
  const now = new Date();
  let elapsed = 0;
  if(freq === 'hourly') {
    elapsed = now.getHours() - startSub;
  } else if(freq === 'daily') {
    const start = new Date(startYear, 0, startSub);
    elapsed = Math.floor((now - start) / 86400000);
  } else if(freq === 'weekly') {
    const start = new Date(startYear, 0, 1 + (startSub - 1) * 7);
    elapsed = Math.floor((now - start) / (7 * 86400000));
  } else if(freq === 'monthly') {
    elapsed = (now.getFullYear() - startYear) * 12 + (now.getMonth() + 1 - startSub);
  } else if(freq === 'quarterly') {
    const nowQ = Math.floor(now.getMonth() / 3) + 1;
    elapsed = (now.getFullYear() - startYear) * 4 + (nowQ - startSub);
  } else if(freq === 'yearly') {
    elapsed = now.getFullYear() - startYear;
  }
  return ((elapsed % period) + period) % period;
}

// Generate a label for a date that is `stepsAhead` periods from today.
// stepsAhead=0 means today, 1 means next period, etc.
function getFutureDateLabel(stepsAhead, freq, period) {
  const now = new Date();
  if(freq === 'hourly') {
    const h = (now.getHours() + stepsAhead) % 24;
    const hStr = h === 0 ? '12a' : h === 12 ? '12p' : h < 12 ? `${h}a` : `${h-12}p`;
    if(period <= 24) return hStr;
    const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    const d = new Date(now);
    d.setHours(d.getHours() + stepsAhead);
    return `${days[d.getDay()]} ${hStr}`;
  }
  if(freq === 'daily') {
    if(period <= 7) return DOW[(now.getDay() + stepsAhead) % 7];
    const d = new Date(now); d.setDate(d.getDate() + stepsAhead);
    return `${MO[d.getMonth()]}${d.getDate()}`;
  }
  if(freq === 'weekly') {
    const d = new Date(now); d.setDate(d.getDate() + stepsAhead * 7);
    return period <= 52 ? MO[d.getMonth()] : `${MO[d.getMonth()]}'${yy(d.getFullYear())}`;
  }
  if(freq === 'monthly') {
    const totalM = now.getFullYear() * 12 + now.getMonth() + stepsAhead;
    const month  = totalM % 12;
    const year   = Math.floor(totalM / 12);
    return period <= 12 ? MO[month] : `${MO[month]}'${yy(year)}`;
  }
  if(freq === 'quarterly') {
    const nowQ   = Math.floor(now.getMonth() / 3);
    const totalQ = now.getFullYear() * 4 + nowQ + stepsAhead;
    const q      = (totalQ % 4) + 1;
    const year   = Math.floor(totalQ / 4);
    return `Q${q}'${yy(year)}`;
  }
  if(freq === 'yearly') {
    return `${new Date().getFullYear() + stepsAhead}`;
  }
  return `${stepsAhead + 1}`;
}

// Wheel tick labels: convert a 0-based phase index into a date label,
// anchored to the dataset's historical start (used on the ring itself).
function getPhaseLabel(phaseIdx, freq, startYear, startSub, period) {
  if(freq === 'hourly') {
    const hour = (startSub + phaseIdx) % 24;
    const hStr = hour === 0 ? '12a' : hour === 12 ? '12p' : hour < 12 ? `${hour}a` : `${hour-12}p`;
    if(period <= 24) return hStr;
    // For multi-day periods, prepend day-of-week
    const dayIdx = Math.floor((startSub + phaseIdx) / 24) % 7;
    const days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
    return `${days[dayIdx % 7]} ${hStr}`;
  }
  if(freq === 'daily') {
    if(period <= 7) return DOW[(startSub + phaseIdx) % 7];
    const d = new Date(startYear, 0, 1 + (startSub - 1) + phaseIdx);
    return `${MO[d.getMonth()]}${d.getDate()}`;
  }
  if(freq === 'weekly') {
    const totalW = (startSub - 1) + phaseIdx;
    const year   = startYear + Math.floor(totalW / 52);
    const month  = Math.min(11, Math.floor((totalW % 52) / 4.33));
    return period <= 52 ? MO[month] : `${MO[month]}'${yy(year)}`;
  }
  if(freq === 'monthly') {
    const totalM = (startSub - 1) + phaseIdx;
    const month  = totalM % 12;
    const year   = startYear + Math.floor(totalM / 12);
    return period <= 12 ? MO[month] : `${MO[month]}'${yy(year)}`;
  }
  if(freq === 'quarterly') {
    const totalQ = (startSub - 1) + phaseIdx;
    const q      = (totalQ % 4) + 1;
    const year   = startYear + Math.floor(totalQ / 4);
    return `Q${q}'${yy(year)}`;
  }
  if(freq === 'yearly') {
    return `${startYear + phaseIdx}`;
  }
  return `${phaseIdx + 1}`;
}

function getPeriodLabel(period, freq) {
  if(freq==="hourly") {
    if(period<=24)  return `${period} hrs`;
    if(period<=168) return `${period} hrs (${(period/24).toFixed(1)} days)`;
    return `${period} hrs (${(period/168).toFixed(1)} wks)`;
  }
  if(freq==="daily") {
    if(period<14)  return `${period} days`;
    if(period<60)  return `${period} days (~${(period/7).toFixed(1)} wks)`;
    if(period<400) return `${period} days (~${(period/30.44).toFixed(1)} mo)`;
    return `${period} days (~${(period/365.25).toFixed(2)} yrs)`;
  }
  if(freq==="quarterly") return `${period} quarters (~${(period/4).toFixed(1)} yrs)`;
  if(freq==="yearly")     return period===1 ? `1 year` : `${period} years`;
  if(freq==="weekly") {
    if(period<=4)   return `${period} wks`;
    if(period<=52)  return `${period} wks (~${(period/4.33).toFixed(1)} mo)`;
    return `${period} wks (~${(period/52.18).toFixed(1)} yrs)`;
  }
  if(period<=24)  return `${period} months`;
  if(period<=240) return `${period} months (~${(period/12).toFixed(1)} yrs)`;
  return `${period} months (~${(period/12).toFixed(0)} yrs)`;
}

function periodRange(freq) {
  if(freq==="hourly")    return [3, 336];  // up to 2 weeks of hours
  if(freq==="daily")     return [3, 730];
  if(freq==="quarterly") return [2, 40];
  if(freq==="yearly")     return [2, 30];
  return [3, 720];
}

// Interpolate between two hex colors 0..1
function lerpColor(a, b, t) {
  const ah = parseInt(a.slice(1),16), bh = parseInt(b.slice(1),16);
  const ar=(ah>>16)&255,ag=(ah>>8)&255,ab=ah&255;
  const br=(bh>>16)&255,bg=(bh>>8)&255,bb=bh&255;
  return `rgb(${Math.round(ar+t*(br-ar))},${Math.round(ag+t*(bg-ag))},${Math.round(ab+t*(bb-ab))})`;
}

// ── Main Component ────────────────────────────────────────────────────────────
export default function CycleViz() {
  const [datasetKey, setDatasetKey]     = useState("S&P 500 Returns");
  const [period, setPeriod]             = useState(12);
  const [showAvg, setShowAvg]           = useState(true);
  const [showCycles, setShowCycles]     = useState(true);
  const [showSpiral, setShowSpiral]     = useState(false);
  const [showLineChart, setShowLineChart] = useState(false);
  const [maxCycles, setMaxCycles]       = useState(8);
  const [currentPhase, setCurrentPhase] = useState(0);
  const [cycleStartYear, setCycleStartYear] = useState(2004);
  const [cycleStartSub,  setCycleStartSub]  = useState(1);
  // Custom data import
  const [showImport, setShowImport]     = useState(false);
  const [importText, setImportText]     = useState("");
  const [importLabel, setImportLabel]   = useState("");
  const [importUnit, setImportUnit]     = useState("");
  const [importFreq, setImportFreq]     = useState("monthly");
  const [importError, setImportError]   = useState("");
  const [customDatasets, setCustomDatasets] = useState({});

  const allDatasets = { ...DATASETS, ...customDatasets };
  const dataset = allDatasets[datasetKey] || allDatasets["NYC Temperature"];
  const { values, freq, hint } = dataset;
  const [pMin, pMax] = periodRange(freq);

  const handleDatasetChange = (key) => {
    const ds = allDatasets[key];
    const newPeriod  = ds?.suggestedPeriod || 12;
    const starts     = DATASET_STARTS[key] || { year:2020, sub:1 };
    const todayPhase = computeTodayPhase(ds?.freq || 'monthly', starts.year, starts.sub, newPeriod);
    setDatasetKey(key);
    setPeriod(newPeriod);
    setMaxCycles(8);
    setCurrentPhase(todayPhase);
    setCycleStartYear(starts.year);
    setCycleStartSub(starts.sub);
  };

  // Parse CSV / plain number list
  const handleImport = () => {
    setImportError("");
    try {
      const raw = importText.trim();
      if(!raw) { setImportError("Paste some numbers first."); return; }
      // Accept: comma, newline, tab, semicolon separated; ignore non-numeric tokens
      const tokens = raw.split(/[\n\r,;\t]+/).map(s=>s.trim()).filter(Boolean);
      // Try to detect if there's a header / label column — skip non-numeric first token
      const nums = tokens.map(t => {
        // Handle tokens like "Q1 2020: 45.3" → take last numeric
        const m = t.match(/-?\d+\.?\d*/);
        return m ? parseFloat(m[0]) : NaN;
      }).filter(n => !isNaN(n));
      if(nums.length < 6) { setImportError("Need at least 6 numeric values."); return; }
      const label = importLabel.trim() || "Custom Dataset";
      const unit  = importUnit.trim() || "";
      const key   = `★ ${label}`;
      const newDs = { values:nums, unit, label, freq:importFreq,
        suggestedPeriod: importFreq==="quarterly"?4:importFreq==="hourly"?24:12,
        hint:`Custom data: ${nums.length} points. Adjust period to find cycles.`, custom:true };
      setCustomDatasets(prev => ({ ...prev, [key]:newDs }));
      const todayYear = new Date().getFullYear();
      const todaySub  = importFreq==="hourly" ? 0 : 1;
      const sugPeriod = importFreq==="quarterly"?4:importFreq==="hourly"?24:12;
      const todayPhase = computeTodayPhase(importFreq, todayYear, todaySub, sugPeriod);
      setCycleStartYear(todayYear);
      setCycleStartSub(todaySub);
      setCurrentPhase(todayPhase);
      setDatasetKey(key);
      setPeriod(sugPeriod);
      setMaxCycles(8);
      setShowImport(false);
      setImportText("");
    } catch(e) {
      setImportError("Could not parse. Try a simple list of numbers.");
    }
  };

  // Whenever period changes, re-anchor currentPhase to today's position in the new period
  const setPeriodAndResync = (newPeriod) => {
    const p = Math.min(pMax, Math.max(pMin, newPeriod));
    setPeriod(p);
    setCurrentPhase(computeTodayPhase(freq, cycleStartYear, cycleStartSub, p));
  };
  const adjPeriod = (d) => setPeriodAndResync(period + d);

  // ── Core computations ──────────────────────────────────────────────────────
  const cycles = useMemo(() => {
    const result = [];
    for(let start=0; start<values.length; start+=period) {
      const slice = values.slice(start, start+period);
      if(slice.length >= Math.floor(period*0.5)) result.push(slice);
    }
    return result;
  }, [values, period]);

  const avgCycle = useMemo(() => {
    const sums = new Array(period).fill(0), counts = new Array(period).fill(0);
    cycles.forEach(c => c.forEach((v,i) => { sums[i]+=v; counts[i]++; }));
    return sums.map((s,i) => counts[i]>0 ? s/counts[i] : 0);
  }, [cycles, period]);

  // Phase strength: normalised deviation of each phase from cycle mean (-1 to +1)
  const phaseStrength = useMemo(() => {
    if(!avgCycle.length) return [];
    const cMin = Math.min(...avgCycle), cMax = Math.max(...avgCycle);
    const cMid = (cMin+cMax)/2, cHalf = (cMax-cMin)/2||1;
    return avgCycle.map(v => (v - cMid)/cHalf); // -1=trough, +1=peak
  }, [avgCycle]);

  // Peak and trough indices
  const peakIdx  = useMemo(() => phaseStrength.indexOf(Math.max(...phaseStrength)), [phaseStrength]);
  const troughIdx = useMemo(() => phaseStrength.indexOf(Math.min(...phaseStrength)), [phaseStrength]);

  // Low peak: the peak of the weakest individual cycle.
  // For each displayed cycle, find its actual maximum value and where it falls.
  // Then pick the cycle whose max is lowest — that's the "low peak" position.
  const lowPeakInfo = useMemo(() => {
    const visible = cycles.slice(0, maxCycles);
    if(visible.length < 2) return null;
    // For each cycle find its max value and the phase index of that max
    const cyclePeaks = visible.map((cyc, ci) => {
      let maxVal = -Infinity, maxPhase = 0;
      cyc.forEach((v, pi) => { if(v > maxVal) { maxVal = v; maxPhase = pi; } });
      return { ci, maxVal, maxPhase };
    });
    // The "low peak" is the cycle whose max is the lowest
    const weakest = cyclePeaks.reduce((a, b) => a.maxVal < b.maxVal ? a : b);
    return weakest;
  }, [cycles, maxCycles]);

  // ── Growth envelope: fits spiral type to peak amplitude across cycles ─────
  const growthEnvelope = useMemo(() => {
    const visibleCycles = cycles.slice(0, maxCycles);
    if(visibleCycles.length < 3 || peakIdx < 0) return null;

    // Peak value for each cycle
    const peakVals = visibleCycles.map(cyc =>
      cyc.length > peakIdx ? cyc[peakIdx] : cyc.reduce((a,b)=>a+b,0)/cyc.length
    );
    const troughVals = visibleCycles.map(cyc =>
      cyc.length > troughIdx ? cyc[troughIdx] : cyc.reduce((a,b)=>a+b,0)/cyc.length
    );
    const N = peakVals.length;
    const xs = peakVals.map((_,i) => i);
    const yMean = peakVals.reduce((a,b)=>a+b,0)/N;
    const xMean = (N-1)/2;

    // Linear fit
    const ssxx  = xs.reduce((s,x)=>s+(x-xMean)**2,0);
    const ssxy  = xs.reduce((s,x,i)=>s+(x-xMean)*(peakVals[i]-yMean),0);
    const linM  = ssxx ? ssxy/ssxx : 0;
    const linB  = yMean - linM*xMean;
    const linPred  = xs.map(x => linM*x + linB);
    const linSS = peakVals.reduce((s,v,i)=>s+(v-linPred[i])**2,0);
    const totSS = peakVals.reduce((s,v)=>s+(v-yMean)**2,0);
    const linR2 = totSS>0 ? Math.max(0, 1-linSS/totSS) : 0;

    // Log fit: ln(y) = ln(a) + b*x
    const logVals  = peakVals.map(v => Math.log(Math.max(0.0001, Math.abs(v))));
    const logYMean = logVals.reduce((a,b)=>a+b,0)/N;
    const logSsxy  = xs.reduce((s,x,i)=>s+(x-xMean)*(logVals[i]-logYMean),0);
    const logM  = ssxx ? logSsxy/ssxx : 0;
    const logB  = logYMean - logM*xMean;
    const logPred  = xs.map(x => Math.exp(logB + logM*x));
    const logSS = peakVals.reduce((s,v,i)=>s+(v-logPred[i])**2,0);
    const logR2 = totSS>0 ? Math.max(0, 1-logSS/totSS) : 0;

    // Relative growth rate per cycle
    const growthRate = yMean !== 0 ? linM / Math.abs(yMean) : 0;
    const growthFactor = peakVals[0] !== 0 ? peakVals[N-1] / Math.abs(peakVals[0]) : 1;

    // Golden ratio test: is growth factor close to φ per revolution?
    const phi = 1.6180339887;
    const goldenTest = Math.abs(growthFactor - Math.pow(phi, N/4)) / Math.pow(phi, N/4);

    let spiralType, spiralColor, spiralDesc, spiralEquation;
    if(Math.abs(growthRate) < 0.04) {
      spiralType = "ARCHIMEDEAN · STABLE";
      spiralColor = "#7ec8e3";
      spiralDesc = "Equal amplitude each revolution — a steady, stable cycle with no secular growth. Nature's metronome.";
      spiralEquation = "r = a + bθ  (b ≈ 0)";
    } else if(goldenTest < 0.15 && logR2 > 0.4 && logM > 0) {
      spiralType = "GOLDEN SPIRAL · φ";
      spiralColor = "#e8d170";
      spiralDesc = "Growth factor approximates the golden ratio φ ≈ 1.618 per quarter turn — the spiral of biological self-similarity.";
      spiralEquation = `r = ae^(bθ)  b ≈ ln(φ)/½π`;
    } else if(logR2 > linR2 && logR2 > 0.35) {
      spiralType = logM > 0 ? "LOGARITHMIC · EXPANDING" : "LOGARITHMIC · CONTRACTING";
      spiralColor = logM > 0 ? "#6de8b8" : "#e87d6d";
      spiralDesc = logM > 0
        ? "Multiplicative growth — each cycle's peak is a constant ratio larger than the last. Compounding in action."
        : "Multiplicative decay — peak amplitudes shrinking by a constant ratio each cycle.";
      spiralEquation = `r = ae^(bθ)  (b = ${logM.toFixed(3)})`;
    } else if(linR2 > 0.35) {
      spiralType = linM > 0 ? "ARCHIMEDEAN · EXPANDING" : "ARCHIMEDEAN · CONTRACTING";
      spiralColor = linM > 0 ? "#b8a3e4" : "#e4a3b8";
      spiralDesc = linM > 0
        ? "Additive growth — each cycle's peak is a constant amount larger. Linear secular trend wrapped in a cycle."
        : "Additive decay — peak amplitudes shrinking by a constant amount each cycle.";
      spiralEquation = `r = a + bθ  (b = ${linM.toFixed(2)})`;
    } else {
      spiralType = "IRREGULAR · NOISY";
      spiralColor = "#e8b86d";
      spiralDesc = "No consistent growth direction — cycle amplitudes vary without a clear trend. Driven by external shocks rather than structural drift.";
      spiralEquation = "r ≈ const  (high variance)";
    }

    // Normalize peaks for spiral drawing (0..1)
    const minP = Math.min(...peakVals), maxP = Math.max(...peakVals);
    const normP = peakVals.map(v => maxP>minP ? (v-minP)/(maxP-minP) : 0.5);
    const normT = troughVals.map(v => maxP>minP ? (v-minP)/(maxP-minP) : 0.5);

    return { peakVals, troughVals, normP, normT, N,
             spiralType, spiralColor, spiralDesc, spiralEquation,
             growthFactor, linR2, logR2, logM, linM };
  }, [cycles, maxCycles, peakIdx, troughIdx]);

  // Coherence (R²)
  const coherenceScore = useMemo(() => {
    if(cycles.length < 2) return 0;
    const sums = new Array(period).fill(0), counts = new Array(period).fill(0);
    cycles.forEach(c => c.forEach((v,i) => { sums[i]+=v; counts[i]++; }));
    const template = sums.map((s,i) => counts[i]>0 ? s/counts[i] : 0);
    const globalMean = values.reduce((a,b)=>a+b,0)/values.length;
    let ssTot=0, ssRes=0;
    values.forEach((v,idx) => {
      ssTot += (v-globalMean)**2;
      ssRes += (v-template[idx%period])**2;
    });
    return ssTot===0 ? 0 : Math.max(0, Math.min(100, Math.round((1-ssRes/ssTot)*200)));
  }, [cycles, period, values]);

  // ── Harmonic alias detection ───────────────────────────────────────────────
  // Compute R² for a given candidate period p against the full values array
  const computeR2 = useCallback((p) => {
    if(p < 2 || values.length < p * 2) return 0;
    const sums = new Array(p).fill(0), counts = new Array(p).fill(0);
    values.forEach((v,i) => { sums[i%p]+=v; counts[i%p]++; });
    const tmpl = sums.map((s,i) => counts[i]>0 ? s/counts[i] : 0);
    const gm = values.reduce((a,b)=>a+b,0)/values.length;
    let ssTot=0, ssRes=0;
    values.forEach((v,i) => { ssTot+=(v-gm)**2; ssRes+=(v-tmpl[i%p])**2; });
    return ssTot===0 ? 0 : Math.max(0, Math.min(100, Math.round((1-ssRes/ssTot)*200)));
  }, [values]);

  // Check whether the current period is a near-integer multiple of a shorter
  // high-coherence period. Returns the strongest alias found, or null.
  const harmonicWarning = useMemo(() => {
    if(coherenceScore < 30 || period < 6) return null;
    const [pMin] = periodRange(freq);
    const candidates = [];
    // Check divisors n=2..8: if period/n is close to an integer candidate period
    for(let n = 2; n <= 8; n++) {
      const subPeriod = period / n;
      if(subPeriod < pMin || subPeriod < 2) continue;
      // Try the two nearest integers around subPeriod
      for(const sp of [Math.round(subPeriod), Math.floor(subPeriod), Math.ceil(subPeriod)]) {
        if(sp < 2 || sp >= period) continue;
        const ratio = period / sp;
        const nearInt = Math.round(ratio);
        const error = Math.abs(ratio - nearInt) / nearInt; // fractional deviation
        if(error > 0.04) continue; // more than 4% off — not a clean harmonic
        const subScore = computeR2(sp);
        if(subScore >= 40) { // sub-period must itself be coherent
          candidates.push({ sp, n: nearInt, subScore, error });
        }
      }
    }
    if(!candidates.length) return null;
    // Return the sub-period with highest coherence
    candidates.sort((a,b) => b.subScore - a.subScore);
    return candidates[0];
  }, [period, coherenceScore, computeR2, freq]);

  const minV = Math.min(...values), maxV = Math.max(...values), range = maxV-minV||1;
  const globalMean = values.reduce((a,b)=>a+b,0)/values.length;

  const cycleToPoints = useCallback((cyc, cx, cy, iR, oR) => {
    return cyc.map((v,i) => {
      const angle = (i/period)*Math.PI*2 - Math.PI/2;
      const r = iR + ((v-minV)/range)*(oR-iR);
      return [cx + r*Math.cos(angle), cy + r*Math.sin(angle)];
    });
  }, [period, minV, range]);

  const toPath = (pts, close=true) => {
    if(!pts.length) return "";
    let d = `M ${pts[0][0].toFixed(2)} ${pts[0][1].toFixed(2)}`;
    for(let i=1;i<pts.length;i++) d += ` L ${pts[i][0].toFixed(2)} ${pts[i][1].toFixed(2)}`;
    return close ? d+" Z" : d;
  };

  // Build a sector path between two angles, between innerR and a radius determined by value
  const sectorPath = useCallback((i, cx, cy, iR, oR) => {
    const a0 = (i/period)*Math.PI*2 - Math.PI/2;
    const a1 = ((i+1)/period)*Math.PI*2 - Math.PI/2;
    const v0 = avgCycle[i], v1 = avgCycle[(i+1)%period];
    const r0 = iR + ((v0-minV)/range)*(oR-iR);
    const r1 = iR + ((v1-minV)/range)*(oR-iR);
    // Sector: inner arc → outer radii → back
    const ix0 = cx + iR*Math.cos(a0), iy0 = cy + iR*Math.sin(a0);
    const ix1 = cx + iR*Math.cos(a1), iy1 = cy + iR*Math.sin(a1);
    const ox0 = cx + r0*Math.cos(a0), oy0 = cy + r0*Math.sin(a0);
    const ox1 = cx + r1*Math.cos(a1), oy1 = cy + r1*Math.sin(a1);
    return `M ${ix0.toFixed(2)} ${iy0.toFixed(2)} L ${ox0.toFixed(2)} ${oy0.toFixed(2)} L ${ox1.toFixed(2)} ${oy1.toFixed(2)} L ${ix1.toFixed(2)} ${iy1.toFixed(2)} Z`;
  }, [avgCycle, period, minV, range]);

  const SIZE=560, CX=SIZE/2, CY=SIZE/2, IR=80, OR=228;

  const ticks = Array.from({length:period}, (_,i) => {
    const angle = (i/period)*Math.PI*2 - Math.PI/2;
    const show = period<=48 || (period<=120&&i%6===0) || (period>120&&i%Math.max(1,Math.round(period/16))===0) || i===0;
    return {
      x1:CX+(OR+8)*Math.cos(angle),  y1:CY+(OR+8)*Math.sin(angle),
      x2:CX+(OR+18)*Math.cos(angle), y2:CY+(OR+18)*Math.sin(angle),
      lx:CX+(OR+32)*Math.cos(angle), ly:CY+(OR+32)*Math.sin(angle),
      label:i+1, show, first:i===0,
    };
  });

  const displayedCycles = cycles.slice(0, maxCycles);
  const cohColor = coherenceScore>70?"#6de8b8":coherenceScore>40?"#e8b86d":coherenceScore>20?"#f0a060":"#e87d6d";
  const cohLabel = coherenceScore>70?"STRONG SIGNAL":coherenceScore>40?"MODERATE":coherenceScore>20?"WEAK":"NOISE";

  // Current phase needle coords
  const needleAngle = (currentPhase/period)*Math.PI*2 - Math.PI/2;
  const needleR = avgCycle.length ? IR + ((avgCycle[currentPhase]-minV)/range)*(OR-IR) : OR;
  const needleX = CX + needleR*Math.cos(needleAngle);
  const needleY = CY + needleR*Math.sin(needleAngle);
  const currentStrength = phaseStrength[currentPhase] ?? 0;
  const currentVal = avgCycle[currentPhase] ?? 0;
  const currentColor = currentStrength > 0.15 ? "#6de8b8" : currentStrength < -0.15 ? "#e87d6d" : "#e8b86d";

  // Forecast: next 2 full cycles from currentPhase
  const forecastCells = useMemo(() => {
    const cells = [];
    const remaining = period - currentPhase;
    for(let i=0; i<remaining; i++) {
      const phase = (currentPhase + i) % period;
      cells.push({ phase, cycleOffset:0, stepsAhead:i,
        strength: phaseStrength[phase]??0, val: avgCycle[phase]??0 });
    }
    for(let i=0; i<period; i++) {
      cells.push({ phase:i, cycleOffset:1, stepsAhead: remaining + i,
        strength: phaseStrength[i]??0, val: avgCycle[i]??0 });
    }
    return cells;
  }, [currentPhase, period, phaseStrength, avgCycle]);

  // ── Render ─────────────────────────────────────────────────────────────────
  return (
    <div style={{minHeight:"100vh", background:"#0a0c12", color:"#d4c9a8",
      fontFamily:"'Courier New',monospace", display:"flex", flexDirection:"column",
      alignItems:"center", padding:"24px 16px 48px"}}>

      {/* Header */}
      <div style={{textAlign:"center", marginBottom:20}}>
        <div style={{fontSize:9, letterSpacing:"0.35em", color:"#7a6f55", marginBottom:4}}>
          CYCLE SEASONALITY ANALYZER
        </div>
        <h1 style={{margin:0, fontSize:24, fontWeight:400, letterSpacing:"0.08em",
          color:"#e8d9b0", textShadow:"0 0 30px rgba(232,184,109,0.3)"}}>
          CIRCULAR PHASE WHEEL
        </h1>
        <div style={{width:60, height:1,
          background:"linear-gradient(90deg,transparent,#e8b86d,transparent)",
          margin:"8px auto 0"}}/>
      </div>

      {/* Controls row */}
      <div style={{display:"flex", gap:12, flexWrap:"wrap", justifyContent:"center",
        marginBottom:12, width:"100%", maxWidth:780}}>

        <div style={controlBox}>
          <label style={ctrlLabel}>DATASET</label>
          <div style={{display:"flex", gap:6, alignItems:"center"}}>
            <select value={datasetKey} onChange={e=>handleDatasetChange(e.target.value)} style={{...selectStyle, flex:1}}>
              <optgroup label="── Built-in ──────────────">
                {Object.keys(DATASETS).map(k=><option key={k} value={k}>{k}</option>)}
              </optgroup>
              {Object.keys(customDatasets).length > 0 && (
                <optgroup label="── Your Data ─────────────">
                  {Object.keys(customDatasets).map(k=><option key={k} value={k}>{k}</option>)}
                </optgroup>
              )}
            </select>
            <button
              onClick={()=>setShowImport(v=>!v)}
              title="Import your own data"
              style={{...btnStyle, width:32, height:32, fontSize:18,
                borderColor: showImport?"rgba(109,232,184,0.5)":"rgba(232,184,109,0.2)",
                color: showImport?"#6de8b8":"#e8b86d",
                background: showImport?"rgba(109,232,184,0.08)":"rgba(232,184,109,0.08)"}}>
              +
            </button>
          </div>
        </div>

        <div style={{...controlBox, minWidth:230}}>
          <label style={ctrlLabel}>
            PERIOD — <span style={{color:"#e8b86d"}}>{getPeriodLabel(period,freq)}</span>
          </label>
          <div style={{display:"flex", alignItems:"center", gap:8}}>
            <button onClick={()=>adjPeriod(-1)} style={btnStyle}>−</button>
            <input type="range" min={pMin} max={pMax} value={period}
              onChange={e=>setPeriodAndResync(Number(e.target.value))}
              style={{flex:1, accentColor:"#e8b86d", cursor:"pointer"}}/>
            <button onClick={()=>adjPeriod(1)} style={btnStyle}>+</button>
          </div>
          {dataset.presets && (
            <div style={{display:"flex", gap:4, flexWrap:"wrap", marginTop:2}}>
              {dataset.presets.map(({p, label}) => {
                const active = p === period;
                return (
                  <button key={p} onClick={()=>setPeriodAndResync(p)} style={{
                    background: active ? "rgba(232,184,109,0.18)" : "rgba(232,184,109,0.04)",
                    border: `1px solid ${active ? "rgba(232,184,109,0.7)" : "rgba(232,184,109,0.2)"}`,
                    color: active ? "#e8b86d" : "rgba(212,201,168,0.45)",
                    padding:"2px 7px", borderRadius:2, cursor:"pointer",
                    fontSize:8, letterSpacing:"0.1em",
                    fontFamily:"'Courier New',monospace",
                    fontWeight: active ? "bold" : "normal",
                    transition:"all 0.12s",
                  }}>
                    {label}
                  </button>
                );
              })}
            </div>
          )}
        </div>

        <div style={{...controlBox, minWidth:160}}>
          <label style={ctrlLabel}>
            CYCLES SHOWN — <span style={{color:"#e8b86d"}}>{Math.min(maxCycles,cycles.length)}/{cycles.length}</span>
          </label>
          <input type="range" min={1} max={Math.min(20,cycles.length)} value={maxCycles}
            onChange={e=>setMaxCycles(Number(e.target.value))}
            style={{width:"100%", accentColor:"#e8b86d", cursor:"pointer"}}/>
        </div>

        {/* Cycle start date */}
        {(() => {
          const subLabel = freq==="hourly"?"START HOUR":freq==="daily"?"START DAY":
                           freq==="weekly"?"START WEEK":freq==="quarterly"?"START QUARTER":
                           freq==="yearly"?"START YEAR":"START MONTH";
          const subMax   = freq==="hourly"?23:freq==="quarterly"?4:freq==="weekly"?52:freq==="yearly"?1:12;
          const subMin   = freq==="hourly"?0:1;
          const subOptions = freq==="monthly"
            ? MO.map((m,i)=>({ val:i+1, label:m }))
            : freq==="quarterly"
            ? [1,2,3,4].map(q=>({ val:q, label:`Q${q}` }))
            : freq==="hourly"
            ? Array.from({length:24},(_,i)=>({ val:i, label: i===0?"12am":i===12?"12pm":i<12?`${i}am`:`${i-12}pm` }))
            : freq==="daily"
            ? DOW.map((d,i)=>({ val:i, label:d }))
            : freq==="yearly"
            ? [{ val:1, label:"Season" }]
            : Array.from({length:52},(_,i)=>({ val:i+1, label:`W${i+1}` }));
          return (
            <div style={{...controlBox, minWidth:160}}>
              <label style={ctrlLabel}>CYCLE START</label>
              <div style={{display:"flex", gap:6, alignItems:"center"}}>
                <select value={cycleStartSub}
                  onChange={e=>{
                    const sub = Number(e.target.value);
                    setCycleStartSub(sub);
                    setCurrentPhase(computeTodayPhase(freq, cycleStartYear, sub, period));
                  }}
                  style={{...selectStyle, flex:1}}>
                  {subOptions.map(o=><option key={o.val} value={o.val}>{o.label}</option>)}
                </select>
                <input type="number" value={cycleStartYear}
                  onChange={e=>{
                    const yr = Number(e.target.value);
                    setCycleStartYear(yr);
                    setCurrentPhase(computeTodayPhase(freq, yr, cycleStartSub, period));
                  }}
                  style={{...selectStyle, width:58, textAlign:"center"}}
                  min={1800} max={2100}/>
              </div>
            </div>
          );
        })()}

        <div style={{...controlBox, flexDirection:"row", gap:10, alignItems:"center"}}>
          <Toggle active={showCycles}    onClick={()=>setShowCycles(v=>!v)}    label="CYCLES"/>
          <Toggle active={showAvg}       onClick={()=>setShowAvg(v=>!v)}       label="AVG"/>
          <Toggle active={showSpiral}    onClick={()=>setShowSpiral(v=>!v)}    label="SPIRAL"/>
          <Toggle active={showLineChart} onClick={()=>setShowLineChart(v=>!v)} label="LINE CHART"/>
        </div>
      </div>

      {/* ── Custom Data Import Panel ── */}
      {showImport && (
        <div style={{width:"100%", maxWidth:710, marginBottom:12,
          background:"rgba(109,232,184,0.03)", border:"1px solid rgba(109,232,184,0.2)",
          borderRadius:3, padding:"14px 16px"}}>
          <div style={{display:"flex", justifyContent:"space-between", alignItems:"baseline", marginBottom:10}}>
            <div>
              <div style={{fontSize:10, letterSpacing:"0.2em", color:"#6de8b8", marginBottom:2}}>
                IMPORT YOUR OWN DATA
              </div>
              <div style={{fontSize:9, color:"rgba(212,201,168,0.4)", lineHeight:1.6}}>
                Paste any list of numbers — CSV, one-per-line, or copied from a spreadsheet column.
                Non-numeric characters are stripped automatically.
              </div>
            </div>
            <button onClick={()=>setShowImport(false)}
              style={{background:"none", border:"none", color:"rgba(212,201,168,0.4)",
                cursor:"pointer", fontSize:16, padding:"0 4px"}}>✕</button>
          </div>

          {/* Meta fields row */}
          <div style={{display:"flex", gap:8, marginBottom:8, flexWrap:"wrap"}}>
            <div style={{flex:2, minWidth:140}}>
              <label style={{...ctrlLabel, display:"block", marginBottom:3}}>DATASET NAME</label>
              <input value={importLabel} onChange={e=>setImportLabel(e.target.value)}
                placeholder="e.g. Q4 Ad Spend 2010–2024"
                style={{...selectStyle, width:"100%", boxSizing:"border-box"}}/>
            </div>
            <div style={{flex:1, minWidth:80}}>
              <label style={{...ctrlLabel, display:"block", marginBottom:3}}>UNIT</label>
              <input value={importUnit} onChange={e=>setImportUnit(e.target.value)}
                placeholder="e.g. $B, %, idx"
                style={{...selectStyle, width:"100%", boxSizing:"border-box"}}/>
            </div>
            <div style={{flex:1, minWidth:100}}>
              <label style={{...ctrlLabel, display:"block", marginBottom:3}}>FREQUENCY</label>
              <select value={importFreq} onChange={e=>setImportFreq(e.target.value)}
                style={{...selectStyle, width:"100%"}}>
                <option value="hourly">Hourly</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="monthly">Monthly</option>
                <option value="quarterly">Quarterly</option>
              </select>
            </div>
          </div>

          {/* Paste area */}
          <textarea
            value={importText}
            onChange={e=>setImportText(e.target.value)}
            placeholder={`Paste numbers here — any of these formats work:\n\n45.2, 48.1, 52.3, 61.8, 70.2, 68.4...\n\n45.2\n48.1\n52.3\n\nOr copy a column straight from Excel / Google Sheets.`}
            style={{width:"100%", minHeight:110, background:"#080a0f",
              border:"1px solid rgba(109,232,184,0.15)", borderRadius:2, padding:"10px",
              color:"#d4c9a8", fontFamily:"'Courier New',monospace", fontSize:11,
              resize:"vertical", outline:"none", boxSizing:"border-box",
              lineHeight:1.6}}
          />

          {importError && (
            <div style={{marginTop:6, fontSize:9, color:"#e87d6d", letterSpacing:"0.1em"}}>
              ⚠ {importError}
            </div>
          )}

          <div style={{display:"flex", gap:8, marginTop:10, alignItems:"center"}}>
            <button onClick={handleImport} style={{
              background:"rgba(109,232,184,0.12)", border:"1px solid rgba(109,232,184,0.4)",
              color:"#6de8b8", padding:"7px 18px", borderRadius:2, cursor:"pointer",
              fontSize:10, letterSpacing:"0.15em", fontFamily:"'Courier New',monospace",
              fontWeight:"bold"}}>
              LOAD ONTO WHEEL →
            </button>
            <div style={{fontSize:9, color:"rgba(212,201,168,0.25)", letterSpacing:"0.1em"}}>
              {importText.trim() ? `~${importText.trim().split(/[\n\r,;\t]+/).filter(s=>s.trim()&&!isNaN(parseFloat(s))).length} values detected` : ""}
            </div>
          </div>

          {/* Format examples */}
          <div style={{marginTop:12, borderTop:"1px solid rgba(109,232,184,0.08)", paddingTop:10}}>
            <div style={{fontSize:8, letterSpacing:"0.15em", color:"rgba(212,201,168,0.25)", marginBottom:6}}>
              EXAMPLE SOURCES — copy the value column and paste above
            </div>
            <div style={{display:"flex", gap:8, flexWrap:"wrap"}}>
              {[
                ["USASpending.gov", "Federal grants by month — free CSV download"],
                ["US Census QSS", "Ad/PR services revenue by quarter"],
                ["Statista", "Ad spend, IPO counts, social metrics"],
                ["Google Trends CSV", "Export any search term as weekly index"],
                ["FRED (St. Louis Fed)", "GDP, unemployment, housing — monthly/quarterly"],
              ].map(([src, desc]) => (
                <div key={src} style={{fontSize:8, color:"rgba(212,201,168,0.35)",
                  background:"rgba(255,255,255,0.02)", border:"1px solid rgba(255,255,255,0.05)",
                  borderRadius:2, padding:"4px 8px", lineHeight:1.6}}>
                  <span style={{color:"rgba(109,232,184,0.5)", fontWeight:"bold"}}>{src}</span>
                  <span style={{color:"rgba(212,201,168,0.25)"}}> — {desc}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Coherence bar */}
      <div style={{width:"100%", maxWidth:710, marginBottom:10,
        background:"rgba(232,184,109,0.02)", border:"1px solid rgba(232,184,109,0.1)",
        borderRadius:3, padding:"8px 14px"}}>
        <div style={{display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:5}}>
          <span style={{fontSize:9, letterSpacing:"0.2em", color:"rgba(212,201,168,0.4)"}}>
            CYCLE COHERENCE (R²)
          </span>
          <span style={{fontSize:11, color:cohColor, fontWeight:"bold"}}>
            {coherenceScore}%{" "}
            <span style={{fontWeight:"normal", color:"rgba(212,201,168,0.35)", fontSize:9}}>— {cohLabel}</span>
          </span>
        </div>
        <div style={{height:4, background:"rgba(255,255,255,0.04)", borderRadius:2, overflow:"hidden"}}>
          <div style={{height:"100%", width:`${coherenceScore}%`,
            background:`linear-gradient(90deg,${cohColor}55,${cohColor})`,
            borderRadius:2, transition:"width 0.3s ease"}}/>
        </div>
        {hint && <div style={{marginTop:5, fontSize:9, color:"rgba(212,201,168,0.28)", letterSpacing:"0.1em"}}>↳ {hint}</div>}
        {harmonicWarning && (() => {
          const { sp, n, subScore } = harmonicWarning;
          const subLabel = getPeriodLabel(sp, freq);
          const curLabel = getPeriodLabel(period, freq);
          return (
            <div style={{
              marginTop:8, padding:"7px 10px", borderRadius:2,
              background:"rgba(232,184,109,0.07)",
              border:"1px solid rgba(232,184,109,0.25)",
              display:"flex", gap:10, alignItems:"flex-start",
            }}>
              <span style={{fontSize:13, lineHeight:1, flexShrink:0}}>⚠</span>
              <div>
                <div style={{fontSize:9, color:"#e8b86d", letterSpacing:"0.15em", fontWeight:"bold", marginBottom:3}}>
                  POSSIBLE HARMONIC ALIAS
                </div>
                <div style={{fontSize:9, color:"rgba(212,201,168,0.55)", lineHeight:1.7}}>
                  Period <span style={{color:"#e8b86d"}}>{curLabel}</span> is ~{n}× a shorter period of{" "}
                  <span style={{color:"#e8b86d"}}>{subLabel}</span>, which also scores{" "}
                  <span style={{color:"#e8b86d"}}>{subScore}%</span> coherence.
                  High coherence here may reflect the shorter cycle repeating {n} times per lap,
                  not a genuine {curLabel} cycle.{" "}
                  <span style={{color:"rgba(212,201,168,0.4)"}}>
                    Try period {sp} to check the fundamental.
                  </span>
                </div>
              </div>
            </div>
          );
        })()}
      </div>

      {/* Stats bar */}
      {(() => {
        const mean = values.reduce((a,b)=>a+b,0)/values.length;
        const stats = [
          { label:"MIN",   value: fmtVal(minV, dataset.unit) },
          { label:"MAX",   value: fmtVal(maxV, dataset.unit) },
          { label:"MEAN",  value: fmtVal(mean, dataset.unit) },
          { label:"RANGE", value: fmtVal(range, dataset.unit) },
          { label:"N",     value: values.length.toLocaleString()+" pts" },
        ];
        return (
          <div style={{width:"100%", maxWidth:710, marginBottom:12,
            display:"flex", borderRadius:3, border:"1px solid rgba(232,184,109,0.1)", overflow:"hidden"}}>
            {stats.map((s,i) => (
              <div key={i} style={{flex:1, padding:"6px 8px", textAlign:"center",
                background:i%2===0?"rgba(232,184,109,0.02)":"rgba(232,184,109,0.04)",
                borderRight:i<4?"1px solid rgba(232,184,109,0.08)":"none"}}>
                <div style={{fontSize:8, letterSpacing:"0.18em", color:"rgba(212,201,168,0.35)", marginBottom:2}}>{s.label}</div>
                <div style={{fontSize:11, color:"#d4c9a8", fontWeight:"bold", whiteSpace:"nowrap"}}>{s.value}</div>
              </div>
            ))}
          </div>
        );
      })()}

      {/* ── Current phase control ── */}
      <div style={{width:"100%", maxWidth:710, marginBottom:14,
        background:"rgba(109,232,184,0.03)", border:"1px solid rgba(109,232,184,0.12)",
        borderRadius:3, padding:"10px 14px"}}>
        <div style={{display:"flex", justifyContent:"space-between", alignItems:"flex-start", marginBottom:8}}>
          <div>
            <div style={{fontSize:9, letterSpacing:"0.2em", color:"rgba(109,232,184,0.6)", marginBottom:2}}>
              YOU ARE HERE — CURRENT PHASE POSITION
            </div>
            <div style={{fontSize:10, color:"rgba(212,201,168,0.4)"}}>
              Set where you are in the cycle to see what the pattern predicts next
            </div>
          </div>
          <div style={{textAlign:"right", flexShrink:0, marginLeft:16}}>
            <div style={{fontSize:18, fontWeight:"bold", color:currentColor, lineHeight:1, letterSpacing:"0.03em"}}>
              {getFutureDateLabel(
                (currentPhase - computeTodayPhase(freq, cycleStartYear, cycleStartSub, period) + period) % period,
                freq, period
              )}
            </div>
            <div style={{fontSize:9, color:"rgba(212,201,168,0.3)", marginTop:1}}>
              position {currentPhase+1} of {period}
            </div>
            <div style={{fontSize:9, color:currentColor, letterSpacing:"0.1em", marginTop:2}}>
              {currentStrength > 0.5 ? "PEAK ZONE" : currentStrength < -0.5 ? "TROUGH ZONE" :
               currentStrength > 0.15 ? "EXPANDING" : currentStrength < -0.15 ? "CONTRACTING" : "NEUTRAL"}
            </div>
            <div style={{fontSize:9, color:"rgba(212,201,168,0.45)", marginTop:1}}>
              avg: {fmtVal(currentVal, dataset.unit)}
            </div>
          </div>
        </div>
        <div style={{display:"flex", alignItems:"center", gap:8}}>
          <button onClick={()=>setCurrentPhase(p=>Math.max(0,p-1))} style={{...btnStyle, borderColor:"rgba(109,232,184,0.2)", color:"#6de8b8"}}>−</button>
          <input type="range" min={0} max={period-1} value={currentPhase}
            onChange={e=>setCurrentPhase(Number(e.target.value))}
            style={{flex:1, accentColor:"#6de8b8", cursor:"pointer"}}/>
          <button onClick={()=>setCurrentPhase(p=>Math.min(period-1,p+1))} style={{...btnStyle, borderColor:"rgba(109,232,184,0.2)", color:"#6de8b8"}}>+</button>
        </div>
      </div>

      {/* SVG wheel */}
      <div style={{border:"1px solid rgba(232,184,109,0.15)", borderRadius:4,
        background:"rgba(232,184,109,0.02)",
        boxShadow:"0 0 60px rgba(232,184,109,0.05),inset 0 0 40px rgba(0,0,0,0.3)",
        padding:8}}>
        <svg width={SIZE} height={SIZE} viewBox={`0 0 ${SIZE} ${SIZE}`} style={{display:"block"}}>
          <defs>
            <radialGradient id="bgGrad" cx="50%" cy="50%" r="50%">
              <stop offset="0%" stopColor="#131620"/>
              <stop offset="100%" stopColor="#0a0c12"/>
            </radialGradient>
            <filter id="avgGlow">
              <feGaussianBlur stdDeviation="3" result="blur"/>
              <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
            <filter id="needleGlow">
              <feGaussianBlur stdDeviation="4" result="blur"/>
              <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
          </defs>

          <rect width={SIZE} height={SIZE} fill="url(#bgGrad)" rx={2}/>

          {/* ── Expansion/contraction zone fills ── */}
          {avgCycle.length > 0 && avgCycle.map((_, i) => {
            const s = phaseStrength[i] ?? 0;
            if(Math.abs(s) < 0.05) return null;
            const isAbove = s > 0;
            // Color: teal for expansion, amber-red for contraction, intensity by strength
            const color = isAbove
              ? lerpColor("#1a3a2a", "#1e5a3a", Math.abs(s))
              : lerpColor("#3a1a1a", "#5a1e1e", Math.abs(s));
            const opacity = 0.25 + Math.abs(s)*0.5;
            return <path key={i} d={sectorPath(i, CX, CY, IR, OR)}
              fill={color} fillOpacity={opacity} stroke="none"/>;
          })}

          {/* Grid rings */}
          {[0.25,0.5,0.75,1.0].map(l => {
            const r = IR + l*(OR-IR);
            const val = minV + l*range;
            const fmtV = Math.abs(val)>=1000?val.toFixed(0):Math.abs(val)>=10?val.toFixed(1):val.toFixed(2);
            const labelText = `${fmtV}${dataset.unit}`;
            const lx = CX - r - 4;
            const labelW = labelText.length*6.5+8;
            return <g key={l}>
              <circle cx={CX} cy={CY} r={r} fill="none"
                stroke={l===1?"rgba(232,184,109,0.18)":"rgba(232,184,109,0.09)"}
                strokeWidth={l===1?1.5:1} strokeDasharray={l===1?"none":"4 6"}/>
              <rect x={lx-labelW} y={CY-7} width={labelW} height={14} rx={3}
                fill="rgba(10,12,18,0.85)" stroke="rgba(232,184,109,0.2)" strokeWidth={0.5}/>
              <text x={lx-4} y={CY+1} textAnchor="end" dominantBaseline="middle"
                fill={l===1?"#e8c87a":"rgba(212,196,158,0.75)"}
                fontSize={9.5} fontFamily="'Courier New',monospace" fontWeight={l===1?"bold":"normal"}>
                {labelText}
              </text>
            </g>;
          })}

          {/* Spokes */}
          {ticks.map((t,i) => <line key={i}
            x1={CX+IR*Math.cos((i/period)*Math.PI*2-Math.PI/2)}
            y1={CY+IR*Math.sin((i/period)*Math.PI*2-Math.PI/2)}
            x2={CX+OR*Math.cos((i/period)*Math.PI*2-Math.PI/2)}
            y2={CY+OR*Math.sin((i/period)*Math.PI*2-Math.PI/2)}
            stroke="rgba(232,184,109,0.06)" strokeWidth={1}/>)}

          {/* Inner circle + min label */}
          <circle cx={CX} cy={CY} r={IR} fill="rgba(0,0,0,0.4)" stroke="rgba(232,184,109,0.2)" strokeWidth={1}/>
          {(() => {
            const lt = fmtVal(minV, dataset.unit);
            return <>
              <rect x={CX-lt.length*3.5-4} y={CY-IR-13} width={lt.length*7+8} height={13} rx={2}
                fill="rgba(10,12,18,0.85)" stroke="rgba(232,184,109,0.15)" strokeWidth={0.5}/>
              <text x={CX} y={CY-IR-4} textAnchor="middle"
                fill="rgba(212,196,158,0.6)" fontSize={9} fontFamily="'Courier New',monospace">{lt}</text>
            </>;
          })()}

          {/* Individual cycles */}
          {showCycles && displayedCycles.map((cyc,ci) => {
            const pts = cycleToPoints(cyc,CX,CY,IR,OR);
            const col = CYCLE_COLORS[ci%CYCLE_COLORS.length];
            return <path key={ci} d={toPath(pts, cyc.length>=period)}
              fill="none" stroke={col} strokeWidth={1}
              strokeOpacity={Math.max(0.07,0.45-ci*0.03)} strokeLinejoin="round"/>;
          })}

          {/* Average cycle */}
          {showAvg && (() => {
            const pts = cycleToPoints(avgCycle,CX,CY,IR,OR);
            return <>
              <path d={toPath(pts)} fill="rgba(232,184,109,0.05)" stroke="none"/>
              <path d={toPath(pts)} fill="none" stroke="#e8b86d"
                strokeWidth={2.5} strokeLinejoin="round" filter="url(#avgGlow)"/>
            </>;
          })()}

          {/* ── Peak marker ── */}
          {avgCycle.length > 0 && (() => {
            const angle = (peakIdx/period)*Math.PI*2 - Math.PI/2;
            const r = IR + ((avgCycle[peakIdx]-minV)/range)*(OR-IR);
            const px = CX + r*Math.cos(angle), py = CY + r*Math.sin(angle);
            const lx = CX + (r+26)*Math.cos(angle), ly = CY + (r+26)*Math.sin(angle);
            return <>
              <circle cx={px} cy={py} r={5} fill="#6de8b8" fillOpacity={0.9}/>
              <circle cx={px} cy={py} r={9} fill="none" stroke="#6de8b8" strokeWidth={1} strokeOpacity={0.4}/>
              <rect x={lx-18} y={ly-10} width={36} height={14} rx={3}
                fill="rgba(10,12,18,0.9)" stroke="rgba(109,232,184,0.4)" strokeWidth={0.8}/>
              <text x={lx} y={ly+1} textAnchor="middle" dominantBaseline="middle"
                fill="#6de8b8" fontSize={8} fontFamily="'Courier New',monospace" fontWeight="bold">PEAK</text>
            </>;
          })()}

          {/* ── Trough marker ── */}
          {avgCycle.length > 0 && (() => {
            const angle = (troughIdx/period)*Math.PI*2 - Math.PI/2;
            const r = IR + ((avgCycle[troughIdx]-minV)/range)*(OR-IR);
            const px = CX + r*Math.cos(angle), py = CY + r*Math.sin(angle);
            const lx = CX + (r-26)*Math.cos(angle), ly = CY + (r-26)*Math.sin(angle);
            return <>
              <circle cx={px} cy={py} r={5} fill="#e87d6d" fillOpacity={0.9}/>
              <circle cx={px} cy={py} r={9} fill="none" stroke="#e87d6d" strokeWidth={1} strokeOpacity={0.4}/>
              <rect x={lx-22} y={ly-10} width={44} height={14} rx={3}
                fill="rgba(10,12,18,0.9)" stroke="rgba(232,125,109,0.4)" strokeWidth={0.8}/>
              <text x={lx} y={ly+1} textAnchor="middle" dominantBaseline="middle"
                fill="#e87d6d" fontSize={8} fontFamily="'Courier New',monospace" fontWeight="bold">TROUGH</text>
            </>;
          })()}

          {/* ── Low peak marker — weakest cycle's actual peak ── */}
          {lowPeakInfo && avgCycle.length > 0 && (() => {
            const { maxVal, maxPhase, ci } = lowPeakInfo;
            const angle = (maxPhase/period)*Math.PI*2 - Math.PI/2;
            const r = IR + ((maxVal-minV)/range)*(OR-IR);
            const px = CX + r*Math.cos(angle), py = CY + r*Math.sin(angle);
            // Place label on the outside of the dot, slightly inward from PEAK label
            const labelR = r + 28;
            const lx = CX + labelR*Math.cos(angle), ly = CY + labelR*Math.sin(angle);
            const col = "#e8c96d"; // amber-yellow — distinct from green peak and red trough
            return <>
              <line x1={CX} y1={CY} x2={px} y2={py}
                stroke={col} strokeWidth={0.6} strokeOpacity={0.15} strokeDasharray="2,4"/>
              <circle cx={px} cy={py} r={5} fill={col} fillOpacity={0.85}/>
              <circle cx={px} cy={py} r={9} fill="none" stroke={col} strokeWidth={1} strokeOpacity={0.35}/>
              <rect x={lx-26} y={ly-10} width={52} height={14} rx={3}
                fill="rgba(10,12,18,0.9)" stroke={`${col}66`} strokeWidth={0.8}/>
              <text x={lx} y={ly+1} textAnchor="middle" dominantBaseline="middle"
                fill={col} fontSize={8} fontFamily="'Courier New',monospace" fontWeight="bold">LOW PEAK</text>
            </>;
          })()}

          {/* ── Current phase needle ── */}
          <line x1={CX} y1={CY} x2={needleX} y2={needleY}
            stroke="#6de8b8" strokeWidth={1.5} strokeOpacity={0.7}
            strokeDasharray="4 3" filter="url(#needleGlow)"/>
          <circle cx={needleX} cy={needleY} r={6} fill="#6de8b8" fillOpacity={0.95}
            filter="url(#needleGlow)"/>
          <circle cx={needleX} cy={needleY} r={11} fill="none"
            stroke="#6de8b8" strokeWidth={1} strokeOpacity={0.35}/>
          {/* Phase label near needle */}
          {(() => {
            const stepsAhead = (currentPhase - computeTodayPhase(freq, cycleStartYear, cycleStartSub, period) + period) % period;
            const lbl = getFutureDateLabel(stepsAhead, freq, period);
            const w = Math.max(28, lbl.length * 7 + 10);
            const lx = CX + (needleR + 20)*Math.cos(needleAngle);
            const ly = CY + (needleR + 20)*Math.sin(needleAngle);
            return <>
              <rect x={lx-w/2} y={ly-9} width={w} height={14} rx={3}
                fill="rgba(10,12,18,0.92)" stroke="rgba(109,232,184,0.5)" strokeWidth={0.8}/>
              <text x={lx} y={ly+1} textAnchor="middle" dominantBaseline="middle"
                fill="#6de8b8" fontSize={lbl.length>5?7:8}
                fontFamily="'Courier New',monospace" fontWeight="bold">
                {lbl}
              </text>
            </>;
          })()}
          {/* Center dot */}
          <circle cx={CX} cy={CY} r={3} fill="#6de8b8" fillOpacity={0.6}/>

          {/* Tick marks */}
          {ticks.map((t,i) => {
            const lbl = getPhaseLabel(i, freq, cycleStartYear, cycleStartSub, period);
            const isActive = i === currentPhase;
            const fs = isActive||t.first ? (lbl.length>5?8:10) : (lbl.length>5?7:9);
            return <g key={i}>
              <line x1={t.x1} y1={t.y1} x2={t.x2} y2={t.y2}
                stroke={isActive?"#6de8b8":t.first?"rgba(232,184,109,0.7)":"rgba(232,184,109,0.4)"}
                strokeWidth={isActive?2.5:t.first?2:1}/>
              {t.show && <text x={t.lx} y={t.ly} textAnchor="middle" dominantBaseline="middle"
                fill={isActive?"#6de8b8":t.first?"#e8b86d":"rgba(232,184,109,0.55)"}
                fontSize={fs} fontWeight={isActive||t.first?"bold":"normal"}
                fontFamily="'Courier New',monospace">{lbl}</text>}
            </g>;
          })}

          {/* Center */}
          <text x={CX} y={CY-14} textAnchor="middle" fill="rgba(232,184,109,0.6)"
            fontSize={10} fontFamily="'Courier New',monospace" letterSpacing="0.1em">PERIOD</text>
          <text x={CX} y={CY+6} textAnchor="middle" fill="#e8b86d"
            fontSize={22} fontWeight="bold" fontFamily="'Courier New',monospace">{period}</text>
          <text x={CX} y={CY+24} textAnchor="middle" fill="rgba(232,184,109,0.45)"
            fontSize={9} fontFamily="'Courier New',monospace">
            {freq==="hourly"?"HOURS":freq==="daily"?"DAYS":freq==="quarterly"?"QUARTERS":"MONTHS"}
          </text>

          {/* Zone legend */}
          <g transform={`translate(14,${SIZE-52})`}>
            <rect width={10} height={10} rx={2} fill="#1e5a3a" fillOpacity={0.8}/>
            <text x={14} y={8} fill="rgba(109,232,184,0.6)" fontSize={8} fontFamily="'Courier New',monospace">EXPANSION</text>
            <rect y={14} width={10} height={10} rx={2} fill="#5a1e1e" fillOpacity={0.8}/>
            <text x={14} y={22} fill="rgba(232,125,109,0.6)" fontSize={8} fontFamily="'Courier New',monospace">CONTRACTION</text>
          </g>

          {/* Corner labels */}
          <text x={14} y={16} fill="rgba(232,184,109,0.3)" fontSize={8}
            fontFamily="'Courier New',monospace">{dataset.label.toUpperCase()}</text>
          {(dataset.label.includes("illustrative") || dataset.custom) && (
            <g transform={`translate(14, 28)`}>
              <rect width={90} height={13} rx={2} fill="rgba(232,184,109,0.08)" stroke="rgba(232,184,109,0.2)" strokeWidth={0.5}/>
              <text x={45} y={9} textAnchor="middle" fill="rgba(232,184,109,0.5)"
                fontSize={7} fontFamily="'Courier New',monospace" letterSpacing="0.1em">
                {dataset.custom ? "★ CUSTOM DATA" : "ILLUSTRATIVE DATA"}
              </text>
            </g>
          )}
          <text x={SIZE-10} y={SIZE-12} textAnchor="end" fill="rgba(232,184,109,0.2)" fontSize={8}
            fontFamily="'Courier New',monospace">{values.length} PTS · {cycles.length} CYCLES</text>

          {/* Legend */}
          {showCycles && displayedCycles.slice(0,5).map((_,i) => (
            <g key={i} transform={`translate(${SIZE-92},${16+i*14})`}>
              <line x1={0} y1={4} x2={14} y2={4} stroke={CYCLE_COLORS[i%CYCLE_COLORS.length]} strokeWidth={1.5} strokeOpacity={0.7}/>
              <text x={18} y={8} fill="rgba(232,184,109,0.4)" fontSize={8} fontFamily="'Courier New',monospace">CYCLE {i+1}</text>
            </g>
          ))}
          {showAvg && (
            <g transform={`translate(${SIZE-92},${16+Math.min(5,displayedCycles.length)*14})`}>
              <line x1={0} y1={4} x2={14} y2={4} stroke="#e8b86d" strokeWidth={2.5}/>
              <text x={18} y={8} fill="#e8b86d" fontSize={8} fontFamily="'Courier New',monospace">AVERAGE</text>
            </g>
          )}
        </svg>
      </div>

      {/* ── Forecast Ribbon ── */}
      {avgCycle.length > 0 && (
        <div style={{width:"100%", maxWidth:710, marginTop:16,
          border:"1px solid rgba(109,232,184,0.15)", borderRadius:3,
          background:"rgba(109,232,184,0.02)", padding:"12px 14px"}}>

          <div style={{display:"flex", justifyContent:"space-between", alignItems:"baseline", marginBottom:10}}>
            <div>
              <div style={{fontSize:9, letterSpacing:"0.2em", color:"rgba(109,232,184,0.6)", marginBottom:2}}>
                SEASONALITY FORECAST
              </div>
              <div style={{fontSize:9, color:"rgba(212,201,168,0.35)"}}>
                Based on historical average cycle — showing what the pattern predicts ahead
              </div>
            </div>
            <div style={{fontSize:9, color:"rgba(212,201,168,0.3)", letterSpacing:"0.1em"}}>
              ← NOW &nbsp;&nbsp; FUTURE →
            </div>
          </div>

          {/* Ribbon: current cycle remainder + next full cycle */}
          <div style={{display:"flex", gap:2, flexWrap:"wrap"}}>
            {forecastCells.map((cell, ci) => {
              const s = cell.strength;
              const isAbove = s > 0;
              const intensity = Math.abs(s);
              const bg = isAbove
                ? `rgba(109,232,184,${0.08 + intensity*0.35})`
                : `rgba(232,125,109,${0.08 + intensity*0.35})`;
              const border = isAbove
                ? `rgba(109,232,184,${0.2 + intensity*0.4})`
                : `rgba(232,125,109,${0.2 + intensity*0.4})`;
              const textColor = isAbove ? "#6de8b8" : "#e87d6d";
              const isCurrent = ci===0 && cell.cycleOffset===0;
              const isNextCycle = cell.cycleOffset===1 && cell.phase===0;

              return (
                <div key={ci} style={{position:"relative"}}>
                  {isNextCycle && (
                    <div style={{position:"absolute", top:-14, left:0, fontSize:7,
                      color:"rgba(212,201,168,0.3)", letterSpacing:"0.1em", whiteSpace:"nowrap"}}>
                      NEXT CYCLE ▼
                    </div>
                  )}
                  <div style={{
                    width:ci===0?44:36, minHeight:54,
                    background:bg,
                    border:`1px solid ${border}`,
                    borderRadius:3,
                    display:"flex", flexDirection:"column",
                    alignItems:"center", justifyContent:"center",
                    gap:2, padding:"4px 2px",
                    outline: isCurrent ? "2px solid #6de8b8" : "none",
                    outlineOffset:1,
                  }}>
                    <div style={{fontSize:7, color:"rgba(212,201,168,0.4)", letterSpacing:"0.03em", textAlign:"center"}}>
                      {getFutureDateLabel(cell.stepsAhead, freq, period)}
                    </div>
                    {/* Strength bar */}
                    <div style={{width:20, height:28, background:"rgba(0,0,0,0.3)", borderRadius:2,
                      display:"flex", flexDirection:"column", justifyContent:"flex-end", overflow:"hidden"}}>
                      <div style={{
                        width:"100%",
                        height:`${Math.max(5, intensity*100)}%`,
                        background:isAbove
                          ? `rgba(109,232,184,${0.5+intensity*0.5})`
                          : `rgba(232,125,109,${0.5+intensity*0.5})`,
                        borderRadius:2,
                      }}/>
                    </div>
                    <div style={{fontSize:7, color:textColor, fontWeight:"bold", letterSpacing:"0.02em"}}>
                      {s > 0.5 ? "▲▲" : s > 0.15 ? "▲" : s < -0.5 ? "▼▼" : s < -0.15 ? "▼" : "—"}
                    </div>
                    <div style={{fontSize:6.5, color:"rgba(212,201,168,0.5)", textAlign:"center", lineHeight:1.2}}>
                      {fmtVal(cell.val, dataset.unit)}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          {/* Phase strength ranking */}
          <div style={{marginTop:12, borderTop:"1px solid rgba(232,184,109,0.08)", paddingTop:10}}>
            <div style={{fontSize:9, letterSpacing:"0.15em", color:"rgba(212,201,168,0.3)", marginBottom:6}}>
              PHASE STRENGTH RANKING — strongest → weakest
            </div>
            <div style={{display:"flex", gap:3, flexWrap:"wrap"}}>
              {[...phaseStrength.map((s,i)=>({s,i}))].sort((a,b)=>b.s-a.s).map(({s,i}) => {
                const isAbove = s > 0;
                const intensity = Math.abs(s);
                const bg = isAbove ? `rgba(109,232,184,${0.06+intensity*0.25})` : `rgba(232,125,109,${0.06+intensity*0.25})`;
                const col = isAbove ? `rgba(109,232,184,${0.4+intensity*0.6})` : `rgba(232,125,109,${0.4+intensity*0.6})`;
                return (
                  <div key={i} style={{
                    padding:"3px 6px", borderRadius:2, background:bg,
                    border:`1px solid ${col}`,
                    fontSize:8, color:col, fontFamily:"'Courier New',monospace",
                    outline: i===currentPhase ? `1.5px solid #6de8b8` : "none",
                  }}>
                    {getPhaseLabel(i, freq, cycleStartYear, cycleStartSub, period)}
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}

      {/* ── Growth Spiral Panel ─────────────────────────────────────────── */}
      {showSpiral && growthEnvelope && (() => {
        const { peakVals, troughVals, normP, normT, N,
                spiralType, spiralColor, spiralDesc, spiralEquation,
                growthFactor } = growthEnvelope;
        const visibleCycles = cycles.slice(0, maxCycles);

        const SC = 150; // svg center
        const maxR = 118;
        const peakAngle = (peakIdx / period) * Math.PI * 2 - Math.PI / 2;
        const troughAngle = (troughIdx / period) * Math.PI * 2 - Math.PI / 2;


        const showGolden      = spiralType.includes('φ');
        const showArchimedean = spiralType.includes('ARCHIMEDEAN');

        // ── Build clear spiral: each cycle = one full revolution, spaced outward ──
        // Radii: innermost cycle at minRing, outermost at maxR
        const minRing = 18;
        const ringStep = N > 1 ? (maxR - minRing) / (N - 1) : 0;

        // For each cycle c, its ring radius at angle θ (relative to cycle start) is:
        //   baseR(c) = minRing + c * ringStep
        //   actual r = baseR * (0.4 + 0.6 * normalizedValue(θ))
        // This gives a clearly distorted ring whose bulge reflects the data shape

        // Build the full spiral polyline: continuous path through all cycles
        const stepsPerRev = 240;
        const spiralPts = [];
        for(let c = 0; c < N; c++) {
          const cyc = visibleCycles[c];
          if(!cyc || cyc.length === 0) continue;
          const baseR = minRing + c * ringStep;
          for(let s = 0; s <= stepsPerRev; s++) {
            const θ_progress = s / stepsPerRev; // 0..1 within this cycle
            const dataIdx = θ_progress * (period - 1);
            const d0 = Math.floor(dataIdx), d1 = Math.min(period-1, d0+1);
            const frac = dataIdx - d0;
            const v0 = (cyc[d0] ?? avgCycle[d0] ?? 0);
            const v1 = (cyc[d1] ?? avgCycle[d1] ?? 0);
            const rawV = v0 + frac*(v1-v0);
            // Normalize to 0..1 using global min/max
            const normV = maxV > minV ? (rawV - minV) / (maxV - minV) : 0.5;
            const r = baseR * (0.35 + 0.65 * normV);
            const θ = -Math.PI/2 + θ_progress * Math.PI * 2; // start at top
            spiralPts.push(`${(SC + r*Math.cos(θ)).toFixed(1)},${(SC + r*Math.sin(θ)).toFixed(1)}`);
          }
        }

        // Peak envelope: connect peak points of each cycle ring
        const envelopePts = visibleCycles.map((cyc, c) => {
          const baseR = minRing + c * ringStep;
          const peakV = cyc[peakIdx] ?? avgCycle[peakIdx] ?? 0;
          const normV = maxV > minV ? (peakV - minV) / (maxV - minV) : 0.5;
          const r = baseR * (0.35 + 0.65 * normV);
          const θ = -Math.PI/2 + (peakIdx / period) * Math.PI * 2;
          return { x: SC + r*Math.cos(θ), y: SC + r*Math.sin(θ), r, c, peakV };
        });

        // Trough envelope
        const troughEnvPts = visibleCycles.map((cyc, c) => {
          const baseR = minRing + c * ringStep;
          const troughV = cyc[troughIdx] ?? avgCycle[troughIdx] ?? 0;
          const normV = maxV > minV ? (troughV - minV) / (maxV - minV) : 0.5;
          const r = baseR * (0.35 + 0.65 * normV);
          const θ = -Math.PI/2 + (troughIdx / period) * Math.PI * 2;
          return { x: SC + r*Math.cos(θ), y: SC + r*Math.sin(θ) };
        });

        // Reference ideal spiral overlay (shown faintly for comparison)
        const refPts = [];
        for(let c = 0; c < N; c++) {
          const baseR = minRing + c * ringStep;
          for(let s = 0; s <= stepsPerRev; s++) {
            const θ_progress = s / stepsPerRev;
            let normV;
            if(showGolden) {
              // Golden: amplitude grows by φ^(c/N) per cycle
              normV = 0.3 + 0.7 * Math.pow(1.618, c/(N||1)) / Math.pow(1.618, 1);
              normV = Math.min(1, normV);
            } else if(spiralType.includes('LOG')) {
              normV = 0.3 + 0.7 * (c/(N-1||1));
            } else {
              normV = 0.55; // stable / archimedean: constant amplitude
            }
            const r = baseR * (0.35 + 0.65 * normV);
            const θ = -Math.PI/2 + θ_progress * Math.PI * 2;
            refPts.push(`${(SC + r*Math.cos(θ)).toFixed(1)},${(SC + r*Math.sin(θ)).toFixed(1)}`);
          }
        }

        return (
          <div style={{width:"100%", maxWidth:710, marginTop:16,
            background:"rgba(12,14,22,0.9)", border:`1px solid ${spiralColor}33`,
            borderRadius:3, padding:"16px 20px"}}>

            {/* Header */}
            <div style={{display:"flex", justifyContent:"space-between", alignItems:"flex-start", marginBottom:14}}>
              <div>
                <div style={{fontSize:9, letterSpacing:"0.2em", color:"rgba(212,201,168,0.35)", marginBottom:3}}>
                  GROWTH ENVELOPE ANALYSIS
                </div>
                <div style={{fontSize:16, letterSpacing:"0.12em", color:spiralColor, fontWeight:"bold"}}>
                  {spiralType}
                </div>
                <div style={{fontSize:9, color:"rgba(212,201,168,0.5)", marginTop:4, maxWidth:360, lineHeight:1.7}}>
                  {spiralDesc}
                </div>
              </div>
              <div style={{textAlign:"right", flexShrink:0, marginLeft:16}}>
                <div style={{fontSize:9, letterSpacing:"0.12em", color:"rgba(212,201,168,0.3)", marginBottom:3}}>
                  EQUATION
                </div>
                <div style={{fontSize:11, color:spiralColor, fontFamily:"'Courier New',monospace"}}>
                  {spiralEquation}
                </div>
                <div style={{fontSize:9, color:"rgba(212,201,168,0.3)", marginTop:6}}>
                  peak × {growthFactor.toFixed(2)} over {N} cycles
                </div>
              </div>
            </div>

            {/* Spiral SVG + reference legend */}
            <div style={{display:"flex", gap:20, alignItems:"flex-start", flexWrap:"wrap"}}>
              <svg width={300} height={300} style={{flexShrink:0}}>
                <defs>
                  <radialGradient id="spiralBg">
                    <stop offset="0%" stopColor="#0a0c12" stopOpacity="1"/>
                    <stop offset="100%" stopColor="#060810" stopOpacity="1"/>
                  </radialGradient>
                  <filter id="spiralGlow">
                    <feGaussianBlur stdDeviation="1.5" result="blur"/>
                    <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                  </filter>
                </defs>
                <rect width={300} height={300} fill="url(#spiralBg)" rx={3}/>

                {/* Ring guides — one per cycle, evenly spaced outward */}
                {visibleCycles.map((_,c) => {
                  const baseR = minRing + c * ringStep;
                  return <circle key={c} cx={SC} cy={SC} r={baseR}
                    fill="none" stroke="rgba(212,201,168,0.05)" strokeWidth={0.8}
                    strokeDasharray="2,4"/>;
                })}

                {/* Reference ideal spiral (faint) */}
                {refPts.length > 0 && (
                  <polyline points={refPts.join(' ')} fill="none"
                    stroke="rgba(212,201,168,0.08)" strokeWidth={1}
                    strokeLinecap="round" strokeLinejoin="round"/>
                )}

                {/* Individual cycle rings — colored, each one its own revolution */}
                {visibleCycles.map((cyc, c) => {
                  const baseR = minRing + c * ringStep;
                  const ringPts = [];
                  for(let s = 0; s <= stepsPerRev; s++) {
                    const θ_progress = s / stepsPerRev;
                    const dataIdx = θ_progress * (period - 1);
                    const d0 = Math.floor(dataIdx), d1 = Math.min(period-1, d0+1);
                    const frac2 = dataIdx - d0;
                    const v0 = cyc[d0] ?? avgCycle[d0] ?? 0;
                    const v1 = cyc[d1] ?? avgCycle[d1] ?? 0;
                    const rawV = v0 + frac2*(v1-v0);
                    const normV = maxV > minV ? (rawV - minV) / (maxV - minV) : 0.5;
                    const r = baseR * (0.35 + 0.65 * normV);
                    const θ = -Math.PI/2 + θ_progress * Math.PI * 2;
                    ringPts.push(`${(SC + r*Math.cos(θ)).toFixed(1)},${(SC + r*Math.sin(θ)).toFixed(1)}`);
                  }
                  const col = CYCLE_COLORS[c % CYCLE_COLORS.length];
                  return <polyline key={c} points={ringPts.join(' ')} fill="none"
                    stroke={col} strokeWidth={1.2} strokeOpacity={0.55}
                    strokeLinecap="round" strokeLinejoin="round"/>;
                })}

                {/* Trough envelope line */}
                <polyline
                  points={troughEnvPts.map(p=>`${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ')}
                  fill="none" stroke="rgba(232,125,109,0.4)" strokeWidth={1}
                  strokeDasharray="3,3" strokeLinecap="round"/>

                {/* Peak envelope line — the growth spiral */}
                <polyline
                  points={envelopePts.map(p=>`${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ')}
                  fill="none" stroke={spiralColor} strokeWidth={2.5} strokeOpacity={0.9}
                  strokeLinecap="round" strokeLinejoin="round"
                  filter="url(#spiralGlow)"/>

                {/* Peak dots with cycle numbers */}
                {envelopePts.map(({x,y,c}) => (
                  <g key={c}>
                    <circle cx={x} cy={y} r={5} fill={CYCLE_COLORS[c%CYCLE_COLORS.length]}
                      fillOpacity={0.9}/>
                    <text x={x} y={y+3.5} textAnchor="middle"
                      fill="#0a0c12" fontSize={5.5} fontFamily="'Courier New',monospace"
                      fontWeight="bold">{c+1}</text>
                  </g>
                ))}

                {/* Center dot */}
                <circle cx={SC} cy={SC} r={3} fill={spiralColor} fillOpacity={0.4}/>

                {/* PEAK / TROUGH direction labels */}
                {(() => {
                  const pθ = -Math.PI/2 + (peakIdx/period)*Math.PI*2;
                  const tθ = -Math.PI/2 + (troughIdx/period)*Math.PI*2;
                  const lr = maxR + 10;
                  return <>
                    <text x={SC+lr*Math.cos(pθ)} y={SC+lr*Math.sin(pθ)+3}
                      textAnchor="middle" fill={spiralColor} fontSize={7}
                      fontFamily="'Courier New',monospace" fillOpacity={0.6}>▲</text>
                    <text x={SC+lr*Math.cos(tθ)} y={SC+lr*Math.sin(tθ)+3}
                      textAnchor="middle" fill="rgba(232,125,109,0.5)" fontSize={7}
                      fontFamily="'Courier New',monospace">▼</text>
                  </>;
                })()}

                {/* Outer label: cycle count */}
                <text x={SC} y={296} textAnchor="middle"
                  fill="rgba(212,201,168,0.2)" fontSize={7}
                  fontFamily="'Courier New',monospace">
                  {N} CYCLES · INNER→OUTER = EARLIEST→LATEST
                </text>
              </svg>

              {/* Right side: reference spirals comparison + data legend */}
              <div style={{flex:1, minWidth:180}}>

                {/* Reference spiral types */}
                <div style={{marginBottom:12}}>
                  <div style={{fontSize:8, letterSpacing:"0.18em", color:"rgba(212,201,168,0.3)", marginBottom:8}}>
                    SPIRAL TYPE REFERENCE
                  </div>
                  {[
                    { name:"GOLDEN (φ)",    color:"#e8d170", eq:"r=ae^(bθ), b=ln(φ)/½π", desc:"Self-similar biological growth" },
                    { name:"LOGARITHMIC",   color:"#6de8b8", eq:"r=ae^(bθ)",              desc:"Constant % growth per turn" },
                    { name:"ARCHIMEDEAN",   color:"#b8a3e4", eq:"r=a+bθ",                 desc:"Constant absolute growth" },
                    { name:"STABLE",        color:"#7ec8e3", eq:"r≈const",                desc:"No secular amplitude trend" },
                  ].map(ref => (
                    <div key={ref.name} style={{
                      display:"flex", alignItems:"flex-start", gap:8,
                      marginBottom:8, padding:"5px 8px", borderRadius:2,
                      background: spiralType.includes(ref.name.split(' ')[0]) || spiralType.includes(ref.name)
                        ? `${ref.color}11` : "transparent",
                      border: `1px solid ${spiralType.includes(ref.name.split(' ')[0]) || spiralType.includes(ref.name)
                        ? ref.color+'44' : "transparent"}`,
                    }}>
                      <div style={{width:10, height:10, borderRadius:"50%", background:ref.color,
                        flexShrink:0, marginTop:1, opacity: spiralType.includes(ref.name.split(' ')[0]) || spiralType.includes(ref.name) ? 1 : 0.3}}/>
                      <div>
                        <div style={{fontSize:8, color:
                          spiralType.includes(ref.name.split(' ')[0]) || spiralType.includes(ref.name)
                          ? ref.color : "rgba(212,201,168,0.3)",
                          letterSpacing:"0.1em", fontWeight:"bold"}}>
                          {ref.name}
                        </div>
                        <div style={{fontSize:7, color:"rgba(212,201,168,0.25)", marginTop:1, fontFamily:"'Courier New',monospace"}}>
                          {ref.eq}
                        </div>
                        <div style={{fontSize:7, color:"rgba(212,201,168,0.3)", marginTop:1}}>
                          {ref.desc}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>

                {/* Peak amplitude bar chart */}
                <div>
                  <div style={{fontSize:8, letterSpacing:"0.18em", color:"rgba(212,201,168,0.3)", marginBottom:6}}>
                    PEAK AMPLITUDE PER CYCLE
                  </div>
                  <div style={{display:"flex", alignItems:"flex-end", gap:2, height:48}}>
                    {normP.map((amp, c) => (
                      <div key={c} title={`Cycle ${c+1}: ${peakVals[c].toFixed(1)}`}
                        style={{
                          flex:1, minWidth:4,
                          height:`${Math.max(8, amp*100)}%`,
                          background:CYCLE_COLORS[c%CYCLE_COLORS.length],
                          opacity:0.7, borderRadius:"1px 1px 0 0",
                          transition:"height 0.2s",
                        }}/>
                    ))}
                  </div>
                  <div style={{display:"flex", justifyContent:"space-between", marginTop:3}}>
                    <span style={{fontSize:7, color:"rgba(212,201,168,0.25)"}}>C1</span>
                    <span style={{fontSize:7, color:"rgba(212,201,168,0.25)"}}>C{N}</span>
                  </div>
                </div>

              </div>
            </div>
          </div>
        );
      })()}

      {/* ── Line Chart Panel ────────────────────────────────────────────── */}
      {showLineChart && (() => {
        const W = 670, H = 220, PAD = { top:18, right:16, bottom:32, left:52 };
        const chartW = W - PAD.left - PAD.right;
        const chartH = H - PAD.top  - PAD.bottom;
        const n = values.length;
        if(n < 2) return null;

        const lo = minV, hi = maxV, vRange = hi - lo || 1;

        // x: index → pixel
        const xOf = i => PAD.left + (i / (n-1)) * chartW;
        // y: value → pixel (inverted)
        const yOf = v => PAD.top + chartH - ((v - lo) / vRange) * chartH;

        // Build main polyline
        const mainPts = values.map((v,i) => `${xOf(i).toFixed(1)},${yOf(v).toFixed(1)}`).join(' ');

        // Average cycle overlay — repeat avgCycle across the full data span
        const avgPts = values.map((_,i) => {
          const v = avgCycle[i % period] ?? 0;
          return `${xOf(i).toFixed(1)},${yOf(v).toFixed(1)}`;
        }).join(' ');

        // Period divider x-positions
        const dividers = [];
        for(let start = period; start < n; start += period) {
          dividers.push(xOf(start));
        }

        // Y-axis tick values (5 ticks)
        const yTicks = [0,0.25,0.5,0.75,1].map(t => ({
          v: lo + t * vRange,
          y: yOf(lo + t * vRange),
        }));

        // X-axis labels: pick ~8 evenly spaced
        const xLabelCount = Math.min(8, n);
        const xStep = Math.floor(n / xLabelCount);
        const xLabels = Array.from({length: xLabelCount}, (_,i) => {
          const idx = Math.min(n-1, i * xStep);
          return { idx, label: getPhaseLabel(idx % period, freq, cycleStartYear, cycleStartSub, period) + (idx===0 || idx % period === 0 ? '' : ''), x: xOf(idx) };
        });

        // Build x-axis date labels using dataset start
        const buildDateLabel = (idx) => {
          if(freq === 'monthly') {
            const totalM = (cycleStartYear * 12 + cycleStartSub - 1) + idx;
            const mo = totalM % 12;
            const yr = Math.floor(totalM / 12);
            // Show year every Jan or first label
            if(mo === 0 || idx === 0) return `Jan'${String(yr).slice(2)}`;
            return MO[mo];
          }
          if(freq === 'quarterly') {
            const totalQ = (cycleStartYear * 4 + cycleStartSub - 1) + idx;
            const q = (totalQ % 4) + 1;
            const yr = Math.floor(totalQ / 4);
            if(q === 1 || idx === 0) return `Q1'${String(yr).slice(2)}`;
            return `Q${q}`;
          }
          if(freq === 'weekly') {
            const totalW = idx;
            const yr = cycleStartYear + Math.floor(totalW / 52);
            const wk = totalW % 52;
            if(wk < 2 || idx === 0) return `'${String(yr).slice(2)}`;
            return `W${wk}`;
          }
          if(freq === 'daily') {
            const d = new Date(cycleStartYear, cycleStartSub - 1, 1);
            d.setDate(d.getDate() + idx);
            return `${MO[d.getMonth()]}${d.getFullYear() % 100}`;
          }
          if(freq === 'hourly') {
            const totalH = cycleStartSub + idx;
            const h = totalH % 24;
            const hStr = h === 0 ? '12a' : h === 12 ? '12p' : h < 12 ? `${h}a` : `${h-12}p`;
            // For datasets spanning multiple days, show the date progression
            if(idx >= 24) {
              const d = new Date(cycleStartYear, 0, 1);
              d.setHours(d.getHours() + totalH);
              return `${MO[d.getMonth()]}${d.getDate()}`;
            }
            return hStr;
          }
          if(freq === 'yearly') {
            return `${cycleStartYear + idx}`;
          }
          return String(idx);
        };

        // Pick clean x-label positions (every N periods or ~8 evenly)
        const labelEvery = Math.max(1, Math.round(n / 8 / period) * period);
        const xLabelsFinal = [];
        for(let i = 0; i < n; i += labelEvery) {
          xLabelsFinal.push({ x: xOf(i), label: buildDateLabel(i) });
        }

        // Shade cycles alternately
        const bands = [];
        for(let c = 0; c * period < n; c++) {
          const x0 = xOf(c * period);
          const x1 = xOf(Math.min(n-1, (c+1)*period - 1));
          bands.push({ x0, x1, even: c % 2 === 0 });
        }

        // "Today" marker
        const todayIdx = (() => {
          const tp = computeTodayPhase(freq, cycleStartYear, cycleStartSub, period);
          const cyclesDone = cycles.length - 1;
          return Math.min(n-1, cyclesDone * period + tp);
        })();
        const todayX = xOf(todayIdx);

        return (
          <div style={{width:"100%", maxWidth:710, marginTop:16,
            background:"rgba(10,12,18,0.95)", border:"1px solid rgba(232,184,109,0.12)",
            borderRadius:3, padding:"14px 16px"}}>

            {/* Header */}
            <div style={{display:"flex", justifyContent:"space-between", alignItems:"baseline", marginBottom:10}}>
              <div style={{fontSize:9, letterSpacing:"0.2em", color:"rgba(212,201,168,0.4)"}}>
                RAW TIME SERIES — {dataset.label.toUpperCase()}
              </div>
              <div style={{display:"flex", gap:14, fontSize:8, color:"rgba(212,201,168,0.3)"}}>
                <span style={{borderBottom:"1.5px solid rgba(232,184,109,0.5)", paddingBottom:1}}>── RAW DATA</span>
                {showAvg && <span style={{borderBottom:"1.5px solid rgba(109,232,184,0.6)", paddingBottom:1}}>── AVG CYCLE</span>}
                <span style={{borderBottom:"1px dashed rgba(232,184,109,0.3)", paddingBottom:1}}>┊ PERIOD DIVIDERS</span>
              </div>
            </div>

            <svg width="100%" viewBox={`0 0 ${W} ${H}`} style={{overflow:"visible"}}>
              {/* Alternate cycle bands */}
              {bands.map(({x0,x1,even},i) => (
                <rect key={i} x={x0} y={PAD.top} width={Math.max(0,x1-x0)} height={chartH}
                  fill={even ? "rgba(232,184,109,0.02)" : "rgba(232,184,109,0.005)"}/>
              ))}

              {/* Y-axis grid lines + labels */}
              {yTicks.map(({v,y},i) => (
                <g key={i}>
                  <line x1={PAD.left} y1={y} x2={PAD.left+chartW} y2={y}
                    stroke="rgba(212,201,168,0.06)" strokeWidth={0.8}/>
                  <text x={PAD.left-5} y={y+3.5} textAnchor="end"
                    fill="rgba(212,201,168,0.35)" fontSize={8}
                    fontFamily="'Courier New',monospace">
                    {Math.abs(v) >= 1000 ? `${(v/1000).toFixed(1)}k` : v.toFixed(Math.abs(v) < 10 ? 1 : 0)}
                  </text>
                </g>
              ))}

              {/* Period divider lines */}
              {dividers.map((x,i) => (
                <line key={i} x1={x} y1={PAD.top} x2={x} y2={PAD.top+chartH}
                  stroke="rgba(232,184,109,0.15)" strokeWidth={0.7} strokeDasharray="2,4"/>
              ))}

              {/* Today marker */}
              <line x1={todayX} y1={PAD.top-4} x2={todayX} y2={PAD.top+chartH}
                stroke="rgba(109,232,184,0.5)" strokeWidth={1} strokeDasharray="3,3"/>
              <text x={todayX+3} y={PAD.top+7} fill="rgba(109,232,184,0.6)"
                fontSize={7} fontFamily="'Courier New',monospace">TODAY</text>

              {/* Avg cycle overlay */}
              {showAvg && (
                <polyline points={avgPts} fill="none"
                  stroke="rgba(109,232,184,0.55)" strokeWidth={1.5}
                  strokeLinecap="round" strokeLinejoin="round"/>
              )}

              {/* Main data line */}
              <polyline points={mainPts} fill="none"
                stroke="rgba(232,184,109,0.8)" strokeWidth={1.5}
                strokeLinecap="round" strokeLinejoin="round"/>

              {/* Axes */}
              <line x1={PAD.left} y1={PAD.top} x2={PAD.left} y2={PAD.top+chartH}
                stroke="rgba(212,201,168,0.15)" strokeWidth={1}/>
              <line x1={PAD.left} y1={PAD.top+chartH} x2={PAD.left+chartW} y2={PAD.top+chartH}
                stroke="rgba(212,201,168,0.15)" strokeWidth={1}/>

              {/* X-axis labels */}
              {xLabelsFinal.map(({x,label},i) => (
                <text key={i} x={x} y={PAD.top+chartH+13} textAnchor="middle"
                  fill="rgba(212,201,168,0.35)" fontSize={8}
                  fontFamily="'Courier New',monospace">{label}</text>
              ))}

              {/* Y-axis unit label */}
              <text x={10} y={PAD.top + chartH/2} textAnchor="middle"
                fill="rgba(212,201,168,0.3)" fontSize={8}
                fontFamily="'Courier New',monospace"
                transform={`rotate(-90, 10, ${PAD.top + chartH/2})`}>
                {dataset.unit}
              </text>

              {/* Coherence annotation */}
              <text x={PAD.left+chartW-4} y={PAD.top+10} textAnchor="end"
                fill="rgba(232,184,109,0.4)" fontSize={8}
                fontFamily="'Courier New',monospace">
                R² {coherenceScore}% · period {getPeriodLabel(period, freq)}
              </text>
            </svg>

            {/* Comparison callout */}
            <div style={{marginTop:8, padding:"7px 10px", borderRadius:2,
              background:"rgba(232,184,109,0.03)", border:"1px solid rgba(232,184,109,0.08)",
              fontSize:8, color:"rgba(212,201,168,0.4)", lineHeight:1.8}}>
              The teal overlay is the averaged cycle pattern folded back onto the timeline.
              Where it tracks the gold line closely, the cycle is explaining real variance.
              Where they diverge, you are looking at noise, shocks, or secular trend that the cycle cannot capture.
            </div>
          </div>
        );
      })()}

      <div style={{marginTop:14, maxWidth:560, textAlign:"center",
        fontSize:9, color:"rgba(212,201,168,0.2)", letterSpacing:"0.15em", lineHeight:2}}>
        FIND YOUR PERIOD · SET YOUR PHASE · READ WHAT COMES NEXT
      </div>
    </div>
  );
}

function Toggle({active,onClick,label}) {
  return <button onClick={onClick} style={{
    background:active?"rgba(232,184,109,0.12)":"transparent",
    border:`1px solid ${active?"rgba(232,184,109,0.5)":"rgba(232,184,109,0.15)"}`,
    color:active?"#e8b86d":"rgba(212,201,168,0.35)",
    padding:"5px 10px", borderRadius:2, cursor:"pointer",
    fontSize:9, letterSpacing:"0.15em", fontFamily:"'Courier New',monospace",
    transition:"all 0.15s",
  }}>{label}</button>;
}

const controlBox = {
  display:"flex", flexDirection:"column", gap:6,
  background:"rgba(232,184,109,0.03)", border:"1px solid rgba(232,184,109,0.1)",
  borderRadius:3, padding:"10px 14px", minWidth:130,
};
const ctrlLabel = {
  fontSize:9, letterSpacing:"0.2em", color:"rgba(212,201,168,0.45)", textTransform:"uppercase",
};
const selectStyle = {
  background:"#0e1018", border:"1px solid rgba(232,184,109,0.2)",
  color:"#d4c9a8", padding:"5px 8px", borderRadius:2,
  fontFamily:"'Courier New',monospace", fontSize:11, cursor:"pointer", outline:"none",
};
const btnStyle = {
  background:"rgba(232,184,109,0.08)", border:"1px solid rgba(232,184,109,0.2)",
  color:"#e8b86d", width:28, height:28, borderRadius:2, cursor:"pointer", fontSize:16,
  display:"flex", alignItems:"center", justifyContent:"center", flexShrink:0,
};

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CycleVisualizer />);
  </script>
</body>
</html>